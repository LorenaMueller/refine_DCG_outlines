/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var poi_zmutt = 
    /* color: #0b4a8b */
    /* shown: false */
    ee.Geometry.Point([7.642595783012829, 46.00088355131704]),
    poi_oberaletsch = 
    /* color: #0b4a8b */
    /* shown: false */
    ee.Geometry.Point([7.969479269132309, 46.42247658348475]),
    poi_unteraar = 
    /* color: #ffc82d */
    /* shown: false */
    ee.Geometry.Point([8.18837776104397, 46.57109412065738]),
    roi_unteraar = 
    /* color: #00ffff */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[8.093277358211939, 46.605423677609075],
          [8.093277358211939, 46.52894816125691],
          [8.286568068661158, 46.52894816125691],
          [8.286568068661158, 46.605423677609075]]], null, false),
    unteraar_gT_polygon = 
    /* color: #98ff00 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[8.258587264217878, 46.565405834410505],
          [8.255840682186628, 46.572014645501696],
          [8.233181380428816, 46.570834559720566],
          [8.223911666073347, 46.570834559720566],
          [8.208805464901472, 46.57673473186028],
          [8.18786277691319, 46.5774427093805],
          [8.156963729061628, 46.599149531830086],
          [8.147350691952253, 46.58664557598989],
          [8.16039695660069, 46.572486672624684],
          [8.175846480526472, 46.56753018293315],
          [8.156963729061628, 46.554546753810335],
          [8.130871199764753, 46.573430714545886],
          [8.118511580624128, 46.56611395982841],
          [8.155247115292097, 46.53825405787602],
          [8.16417350689366, 46.53825405787602],
          [8.19610252300694, 46.55903228968079],
          [8.225628279842878, 46.55667152754723]]]),
    zmutt_gT_polygon = 
    /* color: #00ffff */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[7.6625092885442125, 46.00139938073074],
          [7.6570161244817125, 46.004976554975336],
          [7.6453431508489, 46.00449961177317],
          [7.6322968862004625, 46.00187635066049],
          [7.626460399384056, 46.0023533164783],
          [7.6199372670598375, 46.00759966908666],
          [7.629893626923119, 46.01236864879793],
          [7.6233704945989, 46.01737563495285],
          [7.607234325165306, 46.01713721732037],
          [7.605517711395775, 46.00116089422388],
          [7.6089509389348375, 45.99543690966295],
          [7.6116975209660875, 45.99400582100345],
          [7.6020844838567125, 45.98661127337282],
          [7.607234325165306, 45.982317211721835],
          [7.614787425751244, 45.97993147799447],
          [7.628520335907494, 45.980408632964014],
          [7.631953563446556, 45.982317211721835],
          [7.635730113739525, 45.989235258192736],
          [7.639506664032494, 45.99114353266096],
          [7.657359447235619, 45.99329026279577]]]),
    oberaletsch_gT_polygon = 
    /* color: #bf04c2 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[7.9640601590144655, 46.414936956365],
          [7.976763100908997, 46.40972936809718],
          [7.990496011065247, 46.40310080932459],
          [8.003542275713684, 46.400970030089226],
          [8.008005471514466, 46.40381105057684],
          [8.008348794268372, 46.40925592632512],
          [7.9997657254207155, 46.4156470435118],
          [7.987062783526184, 46.42109073779113],
          [7.9819129422175905, 46.4246406803959],
          [7.987062783526184, 46.4317398721506],
          [7.991869302080872, 46.43931132424458],
          [7.990496011065247, 46.44451608733249],
          [7.985346169756653, 46.44853760916607],
          [7.979509682940247, 46.45918138094234],
          [7.973329873369934, 46.462255861057976],
          [7.957880349444153, 46.46178287541715],
          [7.9558204129207155, 46.456343245205126],
          [7.960626931475403, 46.44640860517826],
          [7.9681800320613405, 46.44049426860716],
          [7.956850381182434, 46.428663669244216],
          [7.9448340847957155, 46.438838139308366],
          [7.928011269854309, 46.43576233705923],
          [7.914965005205872, 46.42582394323029],
          [7.913935036944153, 46.42038072153179],
          [7.920458169268372, 46.41754056403283],
          [7.931444497393372, 46.41919734055254],
          [7.935564370440247, 46.42038072153179],
          [7.9517005398738405, 46.40830903045258],
          [7.963373513506653, 46.405941718855146],
          [7.966463418291809, 46.40972936809718]]]),
    roi_oberaletsch = 
    /* color: #ff0000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[7.912561745928528, 46.462610294473386],
          [7.912561745928528, 46.398720480474125],
          [8.012468667315247, 46.398720480474125],
          [8.012468667315247, 46.462610294473386]]], null, false),
    groundTruth_zmutt_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_zmutt2003"),
    groundTruth_zmutt_2010 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_zmutt2010"),
    groundTruth_zmutt_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_zmutt2016"),
    roi_zmutt = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[7.599852885957441, 46.01744963942263],
          [7.599852885957441, 45.97761969922328],
          [7.661650981660566, 45.97761969922328],
          [7.661650981660566, 46.01744963942263]]], null, false),
    groundTruth_oberaletsch_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_oberaletsch2003"),
    groundTruth_oberaletsch_2010 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_oberaletsch2010"),
    groundTruth_oberaletsch_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_oberaletsch2016"),
    groundTruth_unteraar_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_unteraar2003"),
    groundTruth_unteraar_2010 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_unteraar2010"),
    groundTruth_unteraar_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_unteraar2016"),
    groundTruth_belvedere_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_belvedere2003"),
    roi_belvedere = 
    /* color: #98ff00 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[7.882228685119119, 45.97116574008611],
          [7.882228685119119, 45.929153352388795],
          [7.9320104844355255, 45.929153352388795],
          [7.9320104844355255, 45.97116574008611]]], null, false),
    groundTruth_satopanth_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_satopanth2003"),
    roi_satopanth = 
    /* color: #0b4a8b */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[79.26526797759985, 30.816163937992354],
          [79.26526797759985, 30.729438686838353],
          [79.42868960845922, 30.729438686838353],
          [79.42868960845922, 30.816163937992354]]], null, false),
    zmutt_2015 = ee.FeatureCollection("projects/ee-lorenamuellerthesis/assets/zmutt_2015"),
    oberaletsch_2015 = ee.FeatureCollection("projects/ee-lorenamuellerthesis/assets/oberaletsch_2015"),
    oberaletsch_2014 = ee.FeatureCollection("projects/ee-lorenamuellerthesis/assets/oberaletsch_2014"),
    coherence_zmutt_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/S1A_IW_SLC_20160813_20160825_Stack_ifg_2_flt_deb_TC_coh_IW2_VV_13Aug2016_25Aug2016"),
    rf_input_belvedere_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/belvedere_2016_layers_assets"),
    rf_input_belvedere_2018 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/belvedere_2018_layers_assets"),
    rf_input_belvedere_2020 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/belvedere_2020_layers_assets"),
    rf_input_oberaletsch_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/oberaletsch_2016_layers_assets_ts"),
    rf_input_oberaletsch_2018 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/oberaletsch_2018_layers_assets"),
    rf_input_oberaletsch_2020 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/oberaletsch_2020_layers_assets"),
    rf_input_unteraar_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/unteraar_2016_layers_assets_ts"),
    rf_input_unteraar_2018 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/unteraar_2018_layers_assets"),
    rf_input_unteraar_2020 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/unteraar_2020_layers_assets");
/***** End of imports. If edited, may not auto-convert in the playground. *****/


//=======================================
// 1. Initialization and Imports
//=======================================

// Define the year for which to run the classification (2003, 2010, or 2016)
var selectedYear = 2016;              // Choose between 2010 and 2016

// Define the glaciers to use for training and testing
var trainGlacier1 = 'oberaletsch';  
var trainGlacier2 = 'unteraar';
var testGlacier = 'belvedere';       // Choose between zmutt, unteraar or oberaletsch. Adjust training glcaiers accordingly. 
                                     // For Belvedere and Satopanth, statistical validation is not possible with this approach.

var trainGlaciers = [trainGlacier1, trainGlacier2];

// Define bands to use for classification
var bands = [ 'lstNir', 'ndri', 'lstNir_superPixelMeans','edges', 'smooth',  'ndwi', 'ndsi', 'ndvi', 'slope',  'aspect', 'elevation', 'gradient', 'TPI','inSAR', 'normalizedLst', 'coherence'];

var palettes = require('users/gena/packages:palettes');
var jet = palettes.misc.jet[7];
var visClass = {min: 0, max: 1, palette: ['white', 'black']};
var blueToRed = palettes.colorbrewer.RdYlBu[11];

// Define the glacier input data as a dictionary
var glaciers = {

  'unteraar': {
    roi: roi_unteraar,
    input2016: rf_input_unteraar_2016,
    input2018: rf_input_unteraar_2018,
    input2020: rf_input_unteraar_2020,
    groundTruth2003: groundTruth_unteraar_2003,
    groundTruth2010: groundTruth_unteraar_2010,
    groundTruth2016: groundTruth_unteraar_2016,
    gT_polygon: unteraar_gT_polygon 
  },
  'oberaletsch': {
    roi: roi_oberaletsch,
    input2016: rf_input_oberaletsch_2016,
    input2018: rf_input_oberaletsch_2018,
    input2020: rf_input_oberaletsch_2020,
    groundTruth2003: groundTruth_oberaletsch_2003,
    groundTruth2010: groundTruth_oberaletsch_2010,
    groundTruth2016: groundTruth_oberaletsch_2016,
    groundTruth2018: groundTruth_oberaletsch_2016,
    groundTruth2020: groundTruth_oberaletsch_2016,
    gT_polygon: oberaletsch_gT_polygon 
  },
  'belvedere':{
    roi: roi_belvedere,
    input2016: rf_input_belvedere_2016,
    input2018: rf_input_belvedere_2018,
    input2020: rf_input_belvedere_2020,
    groundTruth2003: groundTruth_belvedere_2003,
    groundTruth2010: groundTruth_belvedere_2003,
    groundTruth2016: groundTruth_belvedere_2003,
    groundTruth2018: groundTruth_belvedere_2003,
    groundTruth2020: groundTruth_belvedere_2003,
    gT_polygon: roi_belvedere
  }
};



// Function to get the correct input and ground truth based on the selected year
function getInputAndGroundTruth(glacierData, year, glacierName) {
  var input, groundTruth;
  
 if(year === 2016){
    input = glacierData.input2016;
    groundTruth = glacierData.groundTruth2016;
  }else if(year === 2018){
    input = glaciers.input2018;
    groundTruth = glaciers.groundTruth2016;
  }else if(year === 2020){
    input = glacierData.input2020;
    groundTruth = glacierData.groundTruth2016;
  }
  
  return {
    input: input,
    groundTruth: groundTruth
  };
}

// Load glacier data for the test glacier
var testGlacierData = glaciers[testGlacier];
var testInputAndGT = getInputAndGroundTruth(testGlacierData, selectedYear, testGlacier);  // Pass glacierName as third argument
print('testInputAndGT', testInputAndGT);
var testInput = testInputAndGT.input;
var testGroundTruth = testInputAndGT.groundTruth;
var testRoi = testGlacierData.roi;

var GroundTruths = {
  'unteraar': getInputAndGroundTruth(glaciers['unteraar'], selectedYear, testGlacier).groundTruth,
  'oberaletsch': getInputAndGroundTruth(glaciers['oberaletsch'], selectedYear, testGlacier).groundTruth,
  'zmutt': getInputAndGroundTruth(glaciers['zmutt'], selectedYear, testGlacier).groundTruth
}

var updatedInputs = {
  'unteraar': getInputAndGroundTruth(glaciers['unteraar'], selectedYear, 'unteraar').input,
  'oberaletsch': getInputAndGroundTruth(glaciers['oberaletsch'], selectedYear, 'oberaletsch').input,
  'belvedere': getInputAndGroundTruth(glaciers['belvedere'], selectedYear, 'belvedere').input
};


//Define band combinations
// Band combinations: 20 combinations with 7-9 input layers per combination
/*
var bandCombinations = [
  ['lstNir', 'ndvi', 'TPI', 'lstNir_superPixelMeans', 'slope', 'ndwi', 'edges', 'elevation'],
  ['ndvi', 'lstNir_superPixelMeans', 'slope', 'gradient', 'aspect', 'inSAR', 'ndsi'],
  ['lstNir', 'ndwi', 'TPI', 'smooth', 'slope', 'elevation', 'ndsi', 'ndvi', 'ndri'],
  ['edges', 'lstNir_superPixelMeans', 'inSAR', 'gradient', 'aspect', 'ndvi', 'TPI', 'slope'],
  ['lstNir', 'ndsi', 'slope', 'aspect', 'ndwi', 'lstNir_superPixelMeans'],
  ['ndvi', 'lstNir', 'TPI', 'lstNir_superPixelMeans', 'slope', 'ndsi', 'ndri', 'smooth', 'edges'],
  ['lstNir', 'ndwi', 'TPI', 'slope', 'gradient', 'inSAR', 'smooth'],
  ['ndri', 'lstNir_superPixelMeans', 'ndsi', 'ndvi', 'edges', 'slope', 'aspect', 'elevation'],
  ['lstNir', 'ndvi', 'ndwi', 'slope', 'gradient', 'smooth', 'lstNir_superPixelMeans', 'inSAR'],
  ['edges', 'lstNir', 'TPI', 'smooth', 'elevation', 'ndvi', 'ndsi', 'ndri', 'slope'],
  ['lstNir_superPixelMeans', 'ndvi', 'ndri', 'inSAR', 'ndsi', 'edges', 'slope'],
  ['ndwi', 'lstNir', 'TPI', 'gradient', 'aspect', 'slope', 'lstNir_superPixelMeans', 'ndsi'],
  ['lstNir_superPixelMeans', 'ndvi', 'smooth', 'elevation', 'ndwi', 'edges', 'ndsi'],
  ['ndsi', 'lstNir', 'ndvi', 'slope', 'TPI', 'lstNir_superPixelMeans', 'aspect', 'gradient'],
  ['lstNir', 'inSAR', 'edges', 'elevation', 'ndwi', 'smooth', 'TPI', 'ndvi'],
  ['ndvi', 'ndsi', 'lstNir_superPixelMeans', 'gradient', 'aspect', 'edges', 'slope', 'elevation'],
  ['lstNir', 'ndwi', 'lstNir_superPixelMeans', 'inSAR', 'slope', 'ndsi', 'TPI'],
  ['edges', 'lstNir', 'TPI', 'smooth', 'elevation', 'ndwi', 'gradient', 'ndri', 'inSAR'],
  ['lstNir_superPixelMeans', 'ndsi', 'lstNir', 'ndwi', 'elevation', 'smooth', 'edges', 'ndri'],
  ['ndvi', 'lstNir_superPixelMeans', 'lstNir', 'inSAR', 'slope', 'aspect', 'TPI', 'ndsi', 'edges']
];

*/
// Band combinations: 20 combinations with 5-6 input layers per combination
/*
var bandCombinations = [

  // All seven bands
  ['slope', 'edges', 'ndri', 'ndsi', 'ndwi', 'glacierInventory', 'ndvi'],
  ['edges', 'ndri', 'ndsi', 'ndwi', 'glacierInventory'],
  ['edges', 'ndri', 'ndsi', 'ndwi', 'ndvi'],
  ['edges', 'ndri', 'ndsi', 'glacierInventory', 'ndvi']
*/


var bandCombinations = [
  ['slope', 'normalizedLst', 'ndri', 'ndsi', 'ndwi', 'coherence', 'ndvi'],
  ['slope', 'normalizedLst', 'ndri', 'ndsi', 'ndwi', 'coherence'],
  ['slope', 'normalizedLst', 'ndri', 'ndsi', 'ndwi', 'ndvi'],
  ['slope', 'normalizedLst', 'ndri', 'ndsi', 'coherence', 'ndvi'],
  ['slope', 'normalizedLst', 'ndri', 'ndwi', 'coherence', 'ndvi'],
  ['slope', 'normalizedLst', 'ndsi', 'ndwi', 'coherence', 'ndvi'],
  ['slope', 'ndri', 'ndsi', 'ndwi', 'coherence', 'ndvi'],
  ['slope', 'normalizedLst', 'ndri', 'ndsi', 'ndwi'],
  ['slope', 'normalizedLst', 'ndri', 'ndsi', 'coherence'],
  ['slope', 'normalizedLst', 'ndri', 'ndwi', 'coherence'],
  ['slope', 'normalizedLst', 'ndsi', 'ndwi', 'coherence'],
  ['slope', 'ndri', 'ndsi', 'ndwi', 'coherence'],
  ['normalizedLst', 'ndri', 'ndsi', 'ndwi', 'coherence'],
  ['slope', 'normalizedLst', 'ndri', 'ndsi', 'ndvi'],
  ['slope', 'normalizedLst', 'ndsi', 'ndwi', 'ndvi'],
  ['slope', 'ndri', 'ndsi', 'ndwi', 'ndvi'],
  ['slope', 'normalizedLst', 'ndri', 'ndwi', 'ndvi'],
  ['slope', 'normalizedLst', 'ndsi', 'coherence', 'ndvi'],
  ['slope', 'ndri', 'ndwi', 'coherence', 'ndvi'],
  ['normalizedLst', 'ndri', 'ndsi', 'ndwi', 'ndvi']
];


/*


var bandCombinations = [
  ['slope', 'lstNir_superPixelMeans', 'inSAR', 'ndsi', 'ndvi', 'ndwi'],
  ['slope', 'lstNir_superPixelMeans', 'inSAR', 'ndsi', 'ndwi'],
  ['slope', 'lstNir_superPixelMeans', 'ndsi', 'ndvi', 'ndwi'],
  ['slope', 'inSAR', 'ndsi', 'ndvi', 'ndwi'],
  ['lstNir_superPixelMeans', 'inSAR', 'ndsi', 'ndvi', 'ndwi'],
  ['slope', 'lstNir_superPixelMeans', 'inSAR', 'ndvi', 'ndwi'],
  ['slope', 'lstNir_superPixelMeans', 'ndsi', 'ndwi'],
  ['slope', 'inSAR', 'ndsi', 'ndwi'],
  ['lstNir_superPixelMeans', 'inSAR', 'ndsi', 'ndwi'],
  ['slope', 'lstNir_superPixelMeans', 'ndvi', 'ndwi'],
  ['slope', 'inSAR', 'ndvi', 'ndwi'],
  ['lstNir_superPixelMeans', 'ndsi', 'ndvi', 'ndwi']
];


*/




/*
var bandCombinations = [
  ['lstNir', 'ndsi', 'ndwi', 'inSAR'],
  ['lstNir', 'ndri', 'ndwi', 'inSAR'],
  ['lstNir', 'ndri', 'ndsi', 'ndwi', 'inSAR'],
  ['lstNir', 'ndri', 'ndsi', 'inSAR'],
  ['lstNir', 'ndri', 'ndsi', 'ndwi'],
  ['elevation', 'lstNir', 'ndri', 'ndsi', 'ndwi', 'inSAR'],
 // ['elevation', 'lstNir', 'ndri', 'ndsi', 'inSAR'],
 // ['elevation', 'ndri', 'ndsi', 'ndwi', 'inSAR'],
 // ['elevation', 'lstNir', 'ndsi', 'ndwi', 'inSAR']
];
*/


// Visualization parameters
var visClass = {min: 0, max: 1, palette: ['white', 'black']};

// Array to store band combinations and validation accuracies
var accuracyList = [];

//=======================================
// 2. Prepare Training Data and Classification
//=======================================

print('updatedInputs', updatedInputs);


// Function to train a classifier, classify, and evaluate accuracy
function runModel(bands, trainGlaciers, testGlacier) {



  // 2.1 Prepare training data for the selected glaciers
  function prepareTrainingData(glacier, input, groundTruth, bands, region) {
    return input.select(bands).addBands(groundTruth).stratifiedSample({
      numPoints:  5000,
      classBand: 'class',
      region: region,
      scale: 30,
      geometries: true
    });
  }


  var trainingData = trainGlaciers.reduce(function(data, glacier) {
    var glacierData = glaciers[glacier];
      if (!updatedInputs[glacier]) {
  print("Error: updatedInputs for", glacier, "is undefined.");
} else {
  print("updatedInputs for", glacier, "exists:", updatedInputs[glacier]);
}
    
    var glacierTrainingData = prepareTrainingData(glacier, updatedInputs[glacier], GroundTruths[glacier], bands, glacierData.roi);
    return data.merge(glacierTrainingData);
  }, ee.FeatureCollection([]));
  
  // 2.2 Balance training data (oversampling)
  var class0 = trainingData.filter(ee.Filter.eq('class', 0));  // Non-DCG
  var class1 = trainingData.filter(ee.Filter.eq('class', 1));  // DCG

  // Oversample the minority class (debris)
  function oversample(minorityClass, targetSize) {
    var minorityCount = minorityClass.size();
    var replicationFactor = targetSize.divide(minorityCount).ceil();
    var replicated = ee.FeatureCollection(ee.List.sequence(0, replicationFactor.subtract(1))
      .map(function(i) { return minorityClass; }))
      .flatten();
    return replicated.randomColumn().limit(targetSize);
  }

  var maxClassSize = class0.size();
  var replicatedClass1 = oversample(class1, maxClassSize);
  var balancedDataset = class0.merge(replicatedClass1);

  // 2.3 Train classifier on the training data
  var classifier = ee.Classifier.smileRandomForest(100).train({
    features: balancedDataset,
    classProperty: 'class',
    inputProperties: bands
  });

  // 2.4 Apply classifier to the testGlacier input
  var classifiedTestGlacier = testInput.select(bands).classify(classifier);

  // 2.5 Sample test data from classified image and ground truth
  var testSamples = classifiedTestGlacier.addBands(maskedTestGroundTruth)
    .stratifiedSample({
      numPoints: 3000,
      classBand: 'class',
      region: testRoi,
      scale: 30,
      geometries: true
    });

  // 2.6 Evaluate the classifier
  var validationSample = testSamples.errorMatrix('class', 'classification');
  var accuracy = validationSample.accuracy();
  var results = classifier.explain();

  // Add accuracy and bands to the list
  accuracyList.push(ee.Feature(null, {
    'Bands': bands.join(', '), 
    'Accuracy': accuracy,
    'importance':results.get('importance')
  }));

  return classifiedTestGlacier; // Return the classified image for mapping
}
//print('trainingData', trainingData);

//=======================================
// 3. Loop Through Band Combinations
//=======================================
var classifiedImages = []; // Array to store classified images
var validClassifications = []; // Array to store valid classified images based on accuracy threshold

bandCombinations.forEach(function(bands) {
  var classifiedImage = runModel(bands, trainGlaciers, testGlacier);
  var accuracy = accuracyList[accuracyList.length - 1].get('Accuracy'); // Get the last added accuracy
  accuracy = ee.Number(accuracy); // Convert to ee.Number for comparison

    classifiedImages.push(classifiedImage);
    validClassifications.push(bands.join(', ')); // Keep track of valid band combinations


});

//=======================================
// 4. Final Classification and Evaluation
//=======================================
if (classifiedImages.length > 0) {
  var combinedClassification = ee.ImageCollection.fromImages(classifiedImages).sum();
  //var classificationCollection = ee.ImageCollection(classifiedImages);
  //print('combinedClassification', combinedClassification);
  //print(classificationCollection.limit(10));

// 4.1 Calculate Otsu's threshold

/*
// Calculate the histogram
var histogram = combinedClassification.reduceRegion({
  reducer: ee.Reducer.histogram(),
  geometry: testRoi,
  scale: 30,  // Adjust scale to your resolution
  maxPixels: 1e13
});
var histInfo = ee.Dictionary(histogram.get('classification'));
var counts = ee.List(histInfo.get('histogram'));
var values = ee.List(histInfo.get('bucketMeans'));


// Extract histogram data
var histInfo = ee.Dictionary(histogram.get('classification'));
var counts = ee.List(histInfo.get('histogram'));
var values = ee.List(histInfo.get('bucketMeans'));

// Calculate total sum of pixels
var totalPixels = counts.reduce(ee.Reducer.sum());

// Function to calculate the weighted sum
var weightedSum = values.zip(counts).map(function(pair) {
  var value = ee.Number(ee.List(pair).get(0));
  var count = ee.Number(ee.List(pair).get(1));
  return value.multiply(count);
});

// Total weighted sum
var sumTotal = ee.Number(weightedSum.reduce(ee.Reducer.sum()));

// Helper function to calculate Otsu's threshold
var otsuThreshold = function(values, counts, totalPixels, sumTotal) {
  // Iterate over the values to find the optimal threshold
  var result = ee.List(values.iterate(function(value, prev) {
    var prevData = ee.Dictionary(prev);

    // Compute weights for the background and foreground
    var weightBackground = prevData.getNumber('weightBackground').add(ee.Number(counts.get(values.indexOf(value))));
    var weightForeground = ee.Number(totalPixels).subtract(weightBackground);

    // Skip this iteration if there's no foreground
    var mask = weightForeground.gt(0);

    var sumBackground = prevData.getNumber('sumBackground').add(ee.Number(value).multiply(ee.Number(counts.get(values.indexOf(value)))));
    var meanBackground = sumBackground.divide(weightBackground);
    var meanForeground = sumTotal.subtract(sumBackground).divide(weightForeground);

    // Compute between-class variance
    var variance = weightBackground.multiply(weightForeground).multiply(meanBackground.subtract(meanForeground).pow(2));

    // Compare variance to find the maximum
    var newMaxVariance = ee.Number(ee.Algorithms.If(
      variance.gt(prevData.get('maxVariance')),
      variance,
      prevData.get('maxVariance')
    ));

    var newThreshold = ee.Number(ee.Algorithms.If(
      variance.gt(prevData.get('maxVariance')),
      value,
      prevData.get('threshold')
    ));

    return ee.Dictionary({
      'maxVariance': newMaxVariance,
      'threshold': newThreshold,
      'weightBackground': weightBackground,
      'sumBackground': sumBackground
    });
  }, ee.Dictionary({
    'maxVariance': ee.Number(-1),
    'threshold': ee.Number(0),
    'weightBackground': ee.Number(0),
    'sumBackground': ee.Number(0)
  })));

  return ee.Number(ee.Dictionary(result).get('threshold'));
};

// Find the optimal Otsu threshold
var thr = otsuThreshold(values, counts, totalPixels, sumTotal);
print('Otsu Threshold:', thr);

*/
var thr = 8;
// 4.2 Apply the threshold to the final classification sum

  // Threshold the combined classification to obtain final classification
  var finalClassification = combinedClassification.where(combinedClassification.lt(thr), 0).where(combinedClassification.gte(thr), 1);
  //print('Final Classification', finalClassification);

  // Stratified sampling to compare classification and ground truth
  var testSamplesFinal = finalClassification.addBands(maskedTestGroundTruth).stratifiedSample({
      numPoints: 3000,
      classBand: 'class',
      region: testRoi,
      scale: 30,
      geometries: true
  });

  // Confusion matrix and accuracy
  var validationSampleFinal = testSamplesFinal.errorMatrix('class', 'classification');
  var accuracyFinal = validationSampleFinal.accuracy();
  //print('Error Matrix Final:', validationSampleFinal);
  //print('Accuracy Final:', accuracyFinal);

// Extract confusion matrix elements
var confusionMatrix = validationSampleFinal.array();
var TP = confusionMatrix.get([1, 1]); // True Positives (Debris correctly identified)
var FP = confusionMatrix.get([0, 1]); // False Positives (Non-debris misclassified as debris)
var FN = confusionMatrix.get([1, 0]); // False Negatives (Debris missed)
var TN = confusionMatrix.get([0, 0]); // True Negatives (Non-debris correctly classified)

// Compute Precision: TP / (TP + FP)
var precision = TP.divide(TP.add(FP));

// Compute Recall (Sensitivity): TP / (TP + FN)
var recall = TP.divide(TP.add(FN));

// Compute F1-Score: 2 * (Precision * Recall) / (Precision + Recall)
var f1Score = precision.multiply(recall).multiply(2).divide(precision.add(recall));


// Add Metrics to Summary

var evaluationMetrics = ee.Feature(null, {
  'Accuracy': accuracyFinal,
  'F1-Score': f1Score,
  'Precision': precision,
  'Recall': recall,
  //'TP':TP,
  //'FP':FP,
  //'FN':FN,
  //'TN':TN
});
print('evaluations metrics', evaluationMetrics);



  accuracyList.push(ee.Feature(null, {
    'Final Accuracy': accuracyFinal
  }));

  var accuracyTable = ee.FeatureCollection(accuracyList);
  //print('Accuracy Table', accuracyTable);

  // Display the final classification
  Map.centerObject(testRoi, 12);
  
  Map.addLayer(combinedClassification, {min:0, max:20, palette: jet}, 'Final Classification sum');
  //Map.addLayer(finalClassification, visClass, 'Final Classification mask');

//==================================================
// 5. Smooth and vectorize final classification mask
//==================================================
/*
// Apply a majority filter to smooth the classified image
var kernel = ee.Kernel.square({radius: 2});
var smoothedClassification = finalClassification.reduceNeighborhood({
  reducer: ee.Reducer.mode(),
  kernel: kernel
});

// Display the classified image
//Map.addLayer(smoothedClassification, {min: 0, max: 1, palette: ['white', 'black']}, 'Smoothed Classified Image');

// Select the relevant band
var classificationBand = smoothedClassification.select('classification_mode');

// Threshold the image to create a binary mask where 1's are kept
var mask = classificationBand.eq(1);
mask = mask.updateMask(mask);

// Convert the binary mask to vectors (polygons)
var polygons = mask.reduceToVectors({
  geometryType: 'polygon',
  reducer: ee.Reducer.countEvery(),
  scale: 30,  // Adjust to your image's resolution
  maxPixels: 1e8,
  geometry: testRoi  // Ensure the geometry of the mask is used
});

Map.addLayer(testInput, {bands: 'coherence'}, 'coherence 2016', false);

//Map.addLayer(zmutt_2015, {}, 'zmutt 2015');
//Map.addLayer(oberaletsch_2014, {}, 'oberaletsch 2014');

// Add the vector layer to the map to visualize the polygons
Map.addLayer(testInput, {bands: 'inSAR'}, 'inSAR', false);
Map.addLayer(testInput, {bands: 'normalizedLst'}, 'normalizedLst', false);
Map.addLayer(polygons, {color: 'red'}, 'Vectorized classification result');


// Print the polygons to the console for inspection
//print('vectorized classification result', polygons);

/*

// alternative methods for thresholding
var dataset = combinedClassification;

// 2. Adaptive Thresholding using Local Mean (Focal Statistics)
var kernel = ee.Kernel.square(20);  // Neighborhood size
var localMean = dataset.reduceNeighborhood({
  reducer: ee.Reducer.mean(),
  kernel: kernel
});

var adaptiveThreshold = dataset.gt(localMean);
Map.addLayer(adaptiveThreshold, {palette: ['black', 'red']}, 'Adaptive Threshold');

// 3. K-means Clustering for Glacier Segmentation
var training = dataset.sample({
  region: testRoi,
  scale: 30,
  numPixels: 5000
});

var clusterer = ee.Clusterer.wekaKMeans(2).train(training);
var clustered = dataset.cluster(clusterer);
Map.addLayer(clustered.randomVisualizer(), {}, 'K-means Clustering');

// 4. Morphological Operations for Smoothing
var binaryMask = adaptiveThreshold
  .focalMode({radius: 1, kernelType: 'square'}) // Smooth small noise
  .focalMax({radius: 1, kernelType: 'circle'})  // Fill gaps
  .selfMask();  // Remove zero pixels

Map.addLayer(binaryMask, {palette: ['black', 'cyan']}, 'Morphologically Processed');

*/
//==========
// 6. Export
//==========
/*
Export.table.toDrive({
  collection: polygons,
  description:'vectorized_approachI_'+selectedYear+testGlacier,
  folder: 'DCG_approachII_GEE_exports',
  fileFormat: 'SHP'
});
Export.image.toDrive({
  image: finalClassification.toDouble(),
  description: 'finalClassification_approachII_' + testGlacier+selectedYear,
  folder: 'DCG_approachII_GEE_exports',
  scale: 30,
  region: testRoi,
  fileFormat: 'GeoTIFF'
});
Export.image.toDrive({
  image: combinedClassification.toDouble(),
  description: 'combinedClassification_approachII_' + testGlacier+selectedYear,
  folder: 'DCG_approachII_GEE_exports',
  scale: 30,
  region: testRoi,
  fileFormat: 'GeoTIFF'
});
Export.image.toDrive({
  image: testInput.toDouble(),
  description: 'testInput_' + testGlacier+selectedYear,
  folder: 'DCG_approachII_GEE_exports',
  scale: 30,
  region: testRoi,
  fileFormat: 'GeoTIFF'
});
Export.table.toDrive({
  collection: accuracyTable,
  description: 'accuracyTable_differentGlaciers_'+testGlacier+selectedYear, 
  folder: 'DCG_approachII_GEE_exports', 
  fileFormat: 'CSV'});
*/

} 
