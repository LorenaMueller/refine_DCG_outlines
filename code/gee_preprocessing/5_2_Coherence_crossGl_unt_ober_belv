/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var poi_zmutt = 
    /* color: #0b4a8b */
    /* shown: false */
    ee.Geometry.Point([7.642595783012829, 46.00088355131704]),
    poi_oberaletsch = 
    /* color: #0b4a8b */
    /* shown: false */
    ee.Geometry.Point([7.969479269132309, 46.42247658348475]),
    poi_unteraar = 
    /* color: #ffc82d */
    /* shown: false */
    ee.Geometry.Point([8.18837776104397, 46.57109412065738]),
    roi_unteraar = 
    /* color: #00ffff */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[8.093277358211939, 46.605423677609075],
          [8.093277358211939, 46.52894816125691],
          [8.286568068661158, 46.52894816125691],
          [8.286568068661158, 46.605423677609075]]], null, false),
    unteraar_gT_polygon = 
    /* color: #98ff00 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[8.258587264217878, 46.565405834410505],
          [8.255840682186628, 46.572014645501696],
          [8.233181380428816, 46.570834559720566],
          [8.223911666073347, 46.570834559720566],
          [8.208805464901472, 46.57673473186028],
          [8.18786277691319, 46.5774427093805],
          [8.156963729061628, 46.599149531830086],
          [8.147350691952253, 46.58664557598989],
          [8.16039695660069, 46.572486672624684],
          [8.175846480526472, 46.56753018293315],
          [8.156963729061628, 46.554546753810335],
          [8.130871199764753, 46.573430714545886],
          [8.118511580624128, 46.56611395982841],
          [8.155247115292097, 46.53825405787602],
          [8.16417350689366, 46.53825405787602],
          [8.19610252300694, 46.55903228968079],
          [8.225628279842878, 46.55667152754723]]]),
    zmutt_gT_polygon = 
    /* color: #00ffff */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[7.6625092885442125, 46.00139938073074],
          [7.6570161244817125, 46.004976554975336],
          [7.6453431508489, 46.00449961177317],
          [7.6322968862004625, 46.00187635066049],
          [7.626460399384056, 46.0023533164783],
          [7.6199372670598375, 46.00759966908666],
          [7.629893626923119, 46.01236864879793],
          [7.6233704945989, 46.01737563495285],
          [7.607234325165306, 46.01713721732037],
          [7.605517711395775, 46.00116089422388],
          [7.6089509389348375, 45.99543690966295],
          [7.6116975209660875, 45.99400582100345],
          [7.6020844838567125, 45.98661127337282],
          [7.607234325165306, 45.982317211721835],
          [7.614787425751244, 45.97993147799447],
          [7.628520335907494, 45.980408632964014],
          [7.631953563446556, 45.982317211721835],
          [7.635730113739525, 45.989235258192736],
          [7.639506664032494, 45.99114353266096],
          [7.657359447235619, 45.99329026279577]]]),
    oberaletsch_gT_polygon = 
    /* color: #bf04c2 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[7.9640601590144655, 46.414936956365],
          [7.976763100908997, 46.40972936809718],
          [7.990496011065247, 46.40310080932459],
          [8.003542275713684, 46.400970030089226],
          [8.008005471514466, 46.40381105057684],
          [8.008348794268372, 46.40925592632512],
          [7.9997657254207155, 46.4156470435118],
          [7.987062783526184, 46.42109073779113],
          [7.9819129422175905, 46.4246406803959],
          [7.987062783526184, 46.4317398721506],
          [7.991869302080872, 46.43931132424458],
          [7.990496011065247, 46.44451608733249],
          [7.985346169756653, 46.44853760916607],
          [7.979509682940247, 46.45918138094234],
          [7.973329873369934, 46.462255861057976],
          [7.957880349444153, 46.46178287541715],
          [7.9558204129207155, 46.456343245205126],
          [7.960626931475403, 46.44640860517826],
          [7.9681800320613405, 46.44049426860716],
          [7.956850381182434, 46.428663669244216],
          [7.9448340847957155, 46.438838139308366],
          [7.928011269854309, 46.43576233705923],
          [7.914965005205872, 46.42582394323029],
          [7.913935036944153, 46.42038072153179],
          [7.920458169268372, 46.41754056403283],
          [7.931444497393372, 46.41919734055254],
          [7.935564370440247, 46.42038072153179],
          [7.9517005398738405, 46.40830903045258],
          [7.963373513506653, 46.405941718855146],
          [7.966463418291809, 46.40972936809718]]]),
    roi_oberaletsch = 
    /* color: #ff0000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[7.912561745928528, 46.462610294473386],
          [7.912561745928528, 46.398720480474125],
          [8.012468667315247, 46.398720480474125],
          [8.012468667315247, 46.462610294473386]]], null, false),
    groundTruth_zmutt_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_zmutt2003"),
    groundTruth_zmutt_2010 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_zmutt2010"),
    groundTruth_zmutt_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_zmutt2016"),
    roi_zmutt = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[7.599852885957441, 46.01744963942263],
          [7.599852885957441, 45.97761969922328],
          [7.661650981660566, 45.97761969922328],
          [7.661650981660566, 46.01744963942263]]], null, false),
    groundTruth_oberaletsch_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_oberaletsch2003"),
    groundTruth_oberaletsch_2010 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_oberaletsch2010"),
    groundTruth_oberaletsch_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_oberaletsch2016"),
    groundTruth_unteraar_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_unteraar2003"),
    groundTruth_unteraar_2010 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_unteraar2010"),
    groundTruth_unteraar_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_unteraar2016"),
    groundTruth_belvedere_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_belvedere2003"),
    roi_belvedere = 
    /* color: #98ff00 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[7.882228685119119, 45.97116574008611],
          [7.882228685119119, 45.929153352388795],
          [7.9320104844355255, 45.929153352388795],
          [7.9320104844355255, 45.97116574008611]]], null, false),
    groundTruth_satopanth_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_satopanth2003"),
    roi_satopanth = 
    /* color: #0b4a8b */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[79.26526797759985, 30.816163937992354],
          [79.26526797759985, 30.729438686838353],
          [79.42868960845922, 30.729438686838353],
          [79.42868960845922, 30.816163937992354]]], null, false),
    coherence_zmutt_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/S1A_IW_SLC_20160813_20160825_Stack_ifg_2_flt_deb_TC_coh_IW2_VV_13Aug2016_25Aug2016"),
    rf_input_unteraar_2018 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/unteraar_2018_layers_assets"),
    rf_input_unteraar_2020 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/unteraar_2020_layers_assets"),
    rf_input_oberaletsch_2018 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/oberaletsch_2018_layers_assets"),
    rf_input_oberaletsch_2020 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/oberaletsch_2020_layers_assets"),
    rf_input_belvedere_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/belvedere_2016_layers_assets"),
    rf_input_belvedere_2020 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/belvedere_2020_layers_assets"),
    rf_input_belvedere_2018 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/belvedere_2018_layers_assets"),
    rf_input_belvedere_2022 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/belvedere_2022_layers_assets"),
    rf_input_oberaletsch_2022 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/oberaletsch_2022_layers_assets"),
    rf_input_unteraar_2022 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/unteraar_2022_layers_assets"),
    sentinel1 = ee.ImageCollection("COPERNICUS/S1_GRD"),
    rf_input_unteraar_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/unteraar_2016_layers_assets"),
    rf_input_oberaletsch_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/oberaletsch_2016_layers_assets"),
    rgi7 = ee.FeatureCollection("projects/ee-lorenamuellerthesis/assets/rgi_central_europe"),
    belvedere18 = ee.FeatureCollection("projects/ee-lorenamuellerthesis/assets/belvedere_outlines/belvedere_2018"),
    belvedere21 = ee.FeatureCollection("projects/ee-lorenamuellerthesis/assets/belvedere_outlines/belvedere_2021"),
    belvedere23 = ee.FeatureCollection("projects/ee-lorenamuellerthesis/assets/belvedere_outlines/belvedere_2023"),
    rf_input_satopanth_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/satopanth_2016_layers_assets"),
    rf_input_zmutt_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/zmutt_2016_layers_assets"),
    rgiAsia = ee.FeatureCollection("projects/ee-lorenamuellerthesis/assets/rgi_v7_satopanth"),
    rf_input_rhone_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/rhone_2016_layers_assets"),
    rf_input_rhone_2018 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/rhone_2018_layers_assets"),
    rf_input_rhone_2020 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/rhone_2020_layers_assets"),
    roi_rhone = 
    /* color: #98ff00 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[8.346350683741685, 46.65478464713902],
          [8.346350683741685, 46.55973262993909],
          [8.435271277003404, 46.55973262993909],
          [8.435271277003404, 46.65478464713902]]], null, false),
    sgi16_debris = ee.FeatureCollection("projects/ee-lorenamuellerthesis/assets/GLAMOS/SGI_2016_debriscover"),
    satopanth_tongue_2017 = ee.FeatureCollection("projects/ee-lorenamuellerthesis/assets/satopanth_tongue_2017"),
    rf_input_zmutt_2018 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/zmutt_2018_layers_assets"),
    rf_input_zmutt_2020 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/zmutt_2020_layers_assets"),
    rf_input_zmutt_2022 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/zmutt_2022_layers_assets"),
    rf_input_zmutt_2024 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/zmutt_2024_layers_assets"),
    rf_input_unteraar_2024 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/unteraar_2024_layers_assets"),
    rf_input_oberaletsch_2024 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/oberaletsch_2024_layers_assets"),
    rf_input_belvedere_2024 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/belvedere_2024_layers_assets");
/***** End of imports. If edited, may not auto-convert in the playground. *****/
/*
Refining Debris-Covered Glacier Outlines Using Land Surface Temperature Data

Updated Approach - including InSAR coherence

 In this script, the input layers for the random forest classification are imported and the classification 
 is performed for one year at a time. 3 glaciers are used for training and a 4. one for testing. 
 The classifier loops through 20 randomly generated band combinations. The results of these 20 classifications
 are combined in a single final image (classification sum). 
 
 Content
 1. Initialization and Imports                    // choose year of interest and glaciers for training and testing
 2. Prepare Training Data and Classification
 3. Loop Through Band Combinations
 4. Final Classification and Evaluation
 5. Smooth and vectorize final classification mask
 
*/

//=======================================
// 1. Initialization and Imports
//=======================================

var selectedYear = 2016;                // Choose between 2016, 2018 and 2020

//var thr = 12;
// Define the glaciers to use for training and testing
var trainGlacier1 = 'oberaletsch';  
var trainGlacier2 = 'unteraar';
//var trainGlacier3 = 'oberaletsch';
var testGlacier = 'zmutt';           

var trainGlaciers = [trainGlacier1
, trainGlacier2
//,trainGlacier3
];

// Define bands to use for classification
var bands = [ 'lstNir', 'ndri', 'lstNir_superPixelMeans','edges', 'smooth',  'ndwi', 'ndsi', 'ndvi', 'slope',  'aspect', 'elevation', 'gradient', 'TPI', 'glacierInventory', 'inSAR', 'normalizedLst', 'coherence', 'VH'];

var palettes = require('users/gena/packages:palettes');
var jet = palettes.misc.jet[7];
var visClass = {min: 0, max: 1, palette: ['white', 'black']};
var blueToRed = palettes.colorbrewer.RdYlBu[11];

// Define the glacier input data as a dictionary
var glaciers = {
  'zmutt': {
    roi: roi_zmutt,
    input2016: rf_input_zmutt_2016,
    input2018: rf_input_zmutt_2018,
    input2020: rf_input_zmutt_2020,
    input2022: rf_input_zmutt_2022,
    input2024: rf_input_zmutt_2024,
    groundTruth2016: groundTruth_zmutt_2016,
    gT_polygon: zmutt_gT_polygon
    //coherence: coherence_zmutt_2016
  },
  'unteraar': {
    roi: roi_unteraar,

    input2016: rf_input_unteraar_2016,
    //buffer: rf_input_unteraar_2016.select('buffer_mask'),
    input2018: rf_input_unteraar_2018,
    input2020: rf_input_unteraar_2020,
    input2022: rf_input_unteraar_2022,
    input2024: rf_input_unteraar_2024,
    groundTruth2016: groundTruth_unteraar_2016,
    gT_polygon: unteraar_gT_polygon 
  },
  'oberaletsch': {
    roi: roi_oberaletsch,
   // buffer: rf_input_oberaletsch_2016.select('buffer_mask'),
    input2016: rf_input_oberaletsch_2016,
    input2018: rf_input_oberaletsch_2018,
    input2020: rf_input_oberaletsch_2020,
    input2022: rf_input_oberaletsch_2022,
    input2024: rf_input_oberaletsch_2024,
    groundTruth2016: groundTruth_oberaletsch_2016,
    gT_polygon: oberaletsch_gT_polygon 
  }
  ,
  'belvedere':{
    roi: roi_belvedere,
    //buffer: rf_input_belvedere_2016.select('buffer_mask'),
    input2016: rf_input_belvedere_2016,
    input2018: rf_input_belvedere_2018,
    input2020: rf_input_belvedere_2020,
    input2022: rf_input_belvedere_2022,
    input2024: rf_input_belvedere_2024,
    groundTruth2016: groundTruth_belvedere_2003,
    gT_polygon: roi_belvedere
  },
  'satopanth':{
    roi: roi_satopanth,
    //buffer: rf_input_satopanth_2016.select('buffer_mask'),
    input2016: rf_input_satopanth_2016,
    groundTruth2016: groundTruth_satopanth_2003,
    gT_polygon: roi_satopanth 
  }
};


// Function to get the correct input and ground truth based on the selected year
function getInputAndGroundTruth(glacierData, year, glacierName) {
  var input, groundTruth;
  
  if (year === 2016) {
    input = glacierData.input2016;
    groundTruth = glacierData.groundTruth2016;
  } else if (year === 2018) {
    input = glacierData.input2018;
    groundTruth = glacierData.groundTruth2016;

  } else if (year === 2020){
    input = glacierData.input2020;
    groundTruth = glacierData.groundTruth2016;
  }else if (year === 2022){
   input = glacierData.input2022;
    groundTruth = glacierData.groundTruth2016; 
  }else if (year === 2024){
   input = glacierData.input2024;
    groundTruth = glacierData.groundTruth2016; 
  }
  
  return {
    input: input,
    groundTruth: groundTruth
  };
}

// Load glacier data for the test glacier
var testGlacierData = glaciers[testGlacier];
var testInputAndGT = getInputAndGroundTruth(testGlacierData, selectedYear, testGlacier);  // Pass glacierName as third argument
var testInput = testInputAndGT.input;
var testGroundTruth = testInputAndGT.groundTruth;
var testRoi = testGlacierData.roi;


// Mask Ground Truth data using the polygon
function maskGroundTruth(groundTruth, polygon) {
  var clippedGT = groundTruth//.clip(polygon);
 // var maskedGT = groundTruth.where(clippedGT.mask().not(), 0);
 var maskedGT = clippedGT
  return maskedGT;
}

var maskedTestGroundTruth = maskGroundTruth(testGroundTruth, testGlacierData.gT_polygon);

// Apply mask to the ground truth for each glacier
var maskedGroundTruths = {
  'unteraar': maskGroundTruth(getInputAndGroundTruth(glaciers['unteraar'], 2016, 'unteraar').groundTruth, glaciers['unteraar'].gT_polygon),
  'oberaletsch': maskGroundTruth(getInputAndGroundTruth(glaciers['oberaletsch'], 2016, 'oberaletsch').groundTruth, glaciers['oberaletsch'].gT_polygon),
  'belvedere': maskGroundTruth(getInputAndGroundTruth(glaciers['belvedere'], 2016, 'belvedere').groundTruth, glaciers['belvedere'].gT_polygon),
  'zmutt': maskGroundTruth(getInputAndGroundTruth(glaciers['zmutt'], 2016, 'zmutt').groundTruth, glaciers['zmutt'].gT_polygon),
  'satopanth': maskGroundTruth(getInputAndGroundTruth(glaciers['satopanth'], 2016, 'satopanth').groundTruth, glaciers['satopanth'].gT_polygon),
};

//=================================================================================================

// Dictionary to store buffers
var buffers = {};

// Function to process a given ROI
function processGlacierBuffer(roi, name) {
  // Load Copernicus DEM
  var dem = ee.ImageCollection("COPERNICUS/DEM/GLO30")
    .filterBounds(roi)
    .select('DEM')
    .mosaic()
    .setDefaultProjection({crs: 'EPSG:4326', scale: 30})
    .rename('elevation');

  // Load RGI Glacier Outlines
if (name === 'satopanth'){
  rgi = ee.FeatureCollection(rgiAsia).filterBounds(roi);
}else{
  var rgi = ee.FeatureCollection(rgi7).filterBounds(roi);
}

  // Clip DEM to glacier areas
  var demClipped = dem.clip(roi).clip(rgi);

  // Normalize DEM within the RGI
  var minElev = demClipped.reduceRegion({
    reducer: ee.Reducer.min(),
    geometry: rgi,
    scale: 30,
    bestEffort: true
  }).getNumber('elevation');

  var maxElev = demClipped.reduceRegion({
    reducer: ee.Reducer.max(),
    geometry: rgi,
    scale: 30,
    bestEffort: true
  }).getNumber('elevation');

  // Ensure no division by zero
  var range = maxElev.subtract(minElev);
  var normDEM = ee.Algorithms.If(
    range.gt(0),
    demClipped.subtract(minElev).divide(range).rename("normalized_elevation"),
    ee.Image(0)
  );

  // Convert to integer (for vectorization)
  normDEM = ee.Image(normDEM).multiply(100).toInt();

  // Mask only areas where elevation is valid
  var lowElevMask = normDEM.lte(10).selfMask();

  // Convert raster to vector (only inside RGI)
  var lowElevVector = lowElevMask.reduceToVectors({
    geometryType: 'polygon',
    reducer: ee.Reducer.countEvery(),
    scale: 30,
    bestEffort: true,
    geometry: rgi
  });

  // **Buffer Creation**
  var lowElevBuffer = lowElevVector.map(function(f) {
    return f.buffer(300);
  });

  var glacierBuffer = rgi.map(function(f) {
    return f.buffer(100);
  });

  // **Merge and dissolve buffers**
  var finalBuffer = glacierBuffer.merge(lowElevBuffer).union();

  // **Store buffer in dictionary**
  buffers[name] = finalBuffer;

  // **Display Results**
  Map.addLayer(normDEM, {min: 0, max: 100, palette: ['blue', 'white', 'red']}, "Normalized DEM - " + name, false);
  Map.addLayer(finalBuffer, {color: 'red'}, 'Final Buffer - ' + name, false);
}

// **Define ROIs and names**
var roiDict = {
  'zmutt': glaciers['zmutt'].roi,
  'unteraar':glaciers['unteraar'].roi,
  'oberaletsch': glaciers['oberaletsch'].roi,
  'belvedere': glaciers['belvedere'].roi,
  'satopanth': glaciers['satopanth'].roi,
};

// **Run function for each ROI**
Object.keys(roiDict).forEach(function(name) {
  processGlacierBuffer(roiDict[name], name);
});

// **Print Buffers Dictionary**
print('Buffers:', buffers);

// Center map on the first ROI
Map.centerObject(testRoi, 12);


//=================================================================================================
var updatedInputs = {
  'unteraar': (getInputAndGroundTruth(glaciers['unteraar'], selectedYear, 'unteraar').input).clip(buffers['unteraar']),
  'oberaletsch': (getInputAndGroundTruth(glaciers['oberaletsch'], selectedYear, 'oberaletsch').input).clip(buffers['oberaletsch']),
  'belvedere': (getInputAndGroundTruth(glaciers['belvedere'], selectedYear, 'belvedere').input).clip(buffers['belvedere']),
  'zmutt': (getInputAndGroundTruth(glaciers['zmutt'], selectedYear, 'zmutt').input).clip(buffers['zmutt']),
  'satopanth': (getInputAndGroundTruth(glaciers['satopanth'], 2016, 'satopanth').input).clip(buffers['satopanth']),
};
var updatedTrainingInputs = {
  'unteraar': (getInputAndGroundTruth(glaciers['unteraar'], 2016, 'unteraar').input).clip(buffers['unteraar']),
  'oberaletsch': (getInputAndGroundTruth(glaciers['oberaletsch'], 2016, 'oberaletsch').input).clip(buffers['oberaletsch']),
  'belvedere': (getInputAndGroundTruth(glaciers['belvedere'], 2016, 'belvedere').input).clip(buffers['belvedere']),
  'zmutt': (getInputAndGroundTruth(glaciers['zmutt'], 2016, 'zmutt').input).clip(buffers['zmutt']),
  'satopanth': (getInputAndGroundTruth(glaciers['satopanth'], 2016, 'satopanth').input).clip(buffers['satopanth'])
};
testInput = updatedInputs[testGlacier];

print('updated inputs', updatedInputs);
Map.addLayer(maskedGroundTruths[testGlacier], visClass, 'Ground Truth ' + selectedYear);
Map.addLayer(updatedInputs[testGlacier], {bands: 'coherence'}, 'coherence' + selectedYear, false);
Map.addLayer(updatedInputs[testGlacier], {bands: 'normalizedLst', palette: jet}, 'normalized LST' + selectedYear, false);
Map.addLayer(updatedInputs[testGlacier], {bands: 'slope', palette: jet}, 'slope' + selectedYear, false);
Map.addLayer(updatedInputs[testGlacier], {bands: 'ndvi', palette: jet}, 'ndvi' + selectedYear, false);
Map.addLayer(updatedInputs[testGlacier], {bands: 'ndsi', palette: jet}, 'ndsi' + selectedYear, false);
Map.addLayer(updatedInputs[testGlacier], {bands: 'ndri', palette: jet}, 'ndri' + selectedYear, false);
Map.addLayer(updatedInputs[testGlacier], {bands: 'ndwi', palette: jet}, 'ndwi' + selectedYear, false);
Map.addLayer(updatedInputs[testGlacier], {bands: 'VH'}, 'vh', false);
Map.addLayer(updatedInputs[testGlacier], {bands: "lstNir_superPixelMeans", palette: blueToRed}, "lstNir_superPixelMeans", false);

//Define band combinations

// Band combinations: 20 combinations with 5-6 input layers per combination

var bandCombinations = [
  ['slope', 'lstNir_superPixelMeans', 'ndri', 'ndsi', 'ndwi', 'coherence', 'ndvi', 'VH'],
  ['slope', 'lstNir_superPixelMeans', 'ndri', 'ndsi', 'ndwi', 'coherence'],
  ['slope', 'lstNir_superPixelMeans', 'ndri', 'ndsi', 'ndwi', 'ndvi', 'VH'],
  ['slope', 'lstNir_superPixelMeans', 'ndri', 'ndsi', 'coherence', 'ndvi', 'VH'],
  ['slope', 'lstNir_superPixelMeans', 'ndri', 'ndwi', 'coherence', 'ndvi', 'VH'],
  ['slope', 'lstNir_superPixelMeans', 'ndsi', 'ndwi', 'coherence', 'ndvi', 'VH'],
  ['slope', 'ndri', 'ndsi', 'ndwi', 'coherence', 'ndvi'],
  ['slope', 'lstNir_superPixelMeans', 'ndri', 'ndsi', 'ndwi', 'VH'],
  ['slope', 'lstNir_superPixelMeans', 'ndri', 'ndsi', 'coherence', 'VH'],
  ['slope', 'lstNir_superPixelMeans', 'ndri', 'ndwi', 'coherence'],
  ['slope', 'lstNir_superPixelMeans', 'ndsi', 'ndwi', 'coherence', 'VH'],
  ['slope', 'ndri', 'ndsi', 'ndwi', 'coherence', 'VH'],
  ['lstNir_superPixelMeans', 'ndri', 'ndsi', 'ndwi', 'coherence'],
  ['slope', 'lstNir_superPixelMeans', 'ndri', 'ndsi', 'ndvi', 'VH'],
  ['slope', 'lstNir_superPixelMeans', 'ndsi', 'ndwi', 'ndvi', 'VH'],
  ['slope', 'ndri', 'ndsi', 'ndwi', 'ndvi'],
  ['slope', 'lstNir_superPixelMeans', 'ndri', 'ndwi', 'ndvi', 'VH'],
  ['slope', 'lstNir_superPixelMeans', 'ndsi', 'coherence', 'ndvi'],
  ['slope', 'ndri', 'ndwi', 'coherence', 'ndvi'],
  ['lstNir_superPixelMeans', 'ndri', 'ndsi', 'ndwi', 'ndvi', 'VH']
];

// using ASF processed coherence: 
/*
var bandCombinations = [
  ['slope', 'lstNir_superPixelMeans', 'ndri', 'ndsi', 'ndwi', 'inSAR', 'ndvi', 'VH'],
  ['slope', 'lstNir_superPixelMeans', 'ndri', 'ndsi', 'ndwi', 'inSAR'],
  ['slope', 'lstNir_superPixelMeans', 'ndri', 'ndsi', 'ndwi', 'ndvi', 'VH'],
  ['slope', 'lstNir_superPixelMeans', 'ndri', 'ndsi', 'inSAR', 'ndvi', 'VH'],
  ['slope', 'lstNir_superPixelMeans', 'ndri', 'ndwi', 'inSAR', 'ndvi', 'VH'],
  ['slope', 'lstNir_superPixelMeans', 'ndsi', 'ndwi', 'inSAR', 'ndvi', 'VH'],
  ['slope', 'ndri', 'ndsi', 'ndwi', 'inSAR', 'ndvi'],
  ['slope', 'lstNir_superPixelMeans', 'ndri', 'ndsi', 'ndwi', 'VH'],
  ['slope', 'lstNir_superPixelMeans', 'ndri', 'ndsi', 'inSAR', 'VH'],
  ['slope', 'lstNir_superPixelMeans', 'ndri', 'ndwi', 'inSAR'],
  ['slope', 'lstNir_superPixelMeans', 'ndsi', 'ndwi', 'inSAR', 'VH'],
  ['slope', 'ndri', 'ndsi', 'ndwi', 'inSAR', 'VH'],
  ['lstNir_superPixelMeans', 'ndri', 'ndsi', 'ndwi', 'inSAR'],
  ['slope', 'lstNir_superPixelMeans', 'ndri', 'ndsi', 'ndvi', 'VH'],
  ['slope', 'lstNir_superPixelMeans', 'ndsi', 'ndwi', 'ndvi', 'VH'],
  ['slope', 'ndri', 'ndsi', 'ndwi', 'ndvi'],
  ['slope', 'lstNir_superPixelMeans', 'ndri', 'ndwi', 'ndvi', 'VH'],
  ['slope', 'lstNir_superPixelMeans', 'ndsi', 'inSAR', 'ndvi'],
  ['slope', 'ndri', 'ndwi', 'inSAR', 'ndvi'],
  ['lstNir_superPixelMeans', 'ndri', 'ndsi', 'ndwi', 'ndvi', 'VH']
];

*/
// Visualization parameters
var visClass = {min: 0, max: 1, palette: ['white', 'black']};

// Array to store band combinations and validation accuracies
var accuracyList = [];

//=======================================
// 2. Prepare Training Data and Classification
//=======================================

//var trainRoi = buffers[trainGlaciers];
//var testRoi = buffers[testGlacier];
// Function to train a classifier, classify, and evaluate accuracy
function runModel(bands, trainGlaciers, testGlacier) {

  // 2.1 Prepare training data for the selected glaciers
  function prepareTrainingData(glacier, input, groundTruth, bands, region) {
    return input.select(bands).addBands(groundTruth).stratifiedSample({
      numPoints:  2500,
      classBand: 'class',
      region: region,
      scale: 30,
      geometries: true
    });
  }

  var trainingData = trainGlaciers.reduce(function(data, glacier) {
    var glacierData = glaciers[glacier];
    var glacierTrainingData = prepareTrainingData(glacier, updatedTrainingInputs[glacier], maskedGroundTruths[glacier], bands, glacierData.roi);
    return data.merge(glacierTrainingData);
  }, ee.FeatureCollection([]));
  
  // 2.2 Balance training data (oversampling)
  var class0 = trainingData.filter(ee.Filter.eq('class', 0));  // Non-DCG
  var class1 = trainingData.filter(ee.Filter.eq('class', 1));  // DCG

  // Oversample the minority class (debris)
  function oversample(minorityClass, targetSize) {
    var minorityCount = minorityClass.size();
    var replicationFactor = targetSize.divide(minorityCount).ceil();
    var replicated = ee.FeatureCollection(ee.List.sequence(0, replicationFactor.subtract(1))
      .map(function(i) { return minorityClass; }))
      .flatten();
    return replicated.randomColumn().limit(targetSize);
  }

  var maxClassSize = class0.size();
  var replicatedClass1 = oversample(class1, maxClassSize);
  var class1size = replicatedClass1.size();

  var balancedDataset = class0.merge(replicatedClass1);

  // 2.3 Train classifier on the training data
  var classifier = ee.Classifier.smileRandomForest(50).train({
    features: balancedDataset,
    classProperty: 'class',
    inputProperties: bands
  });

  // 2.4 Apply classifier to the testGlacier input
  var classifiedTestGlacier = testInput.select(bands).classify(classifier);

  // 2.5 Sample test data from classified image and ground truth
  var testSamples = classifiedTestGlacier.addBands(maskedTestGroundTruth)
    .stratifiedSample({
      numPoints: 2500,
      classBand: 'class',
      region: buffers[testGlacier],
      scale: 30,
      geometries: true
    });

  // 2.6 Evaluate the classifier
  var validationSample = testSamples.errorMatrix('class', 'classification');
  var accuracy = validationSample.accuracy();
  var results = classifier.explain();

  // Add accuracy and bands to the list
  accuracyList.push(ee.Feature(null, {
    'Bands': bands.join(', '), 
    'Accuracy': accuracy,
    'importance':results.get('importance'),
    'class size 0': maxClassSize,
    'class size 1': class1size
  }));

  return classifiedTestGlacier; // Return the classified image for mapping
}

//print('trainingData', trainingData);

//=======================================
// 3. Loop Through Band Combinations
//=======================================
var classifiedImages = []; // Array to store classified images
var validClassifications = []; // Array to store valid classified images based on accuracy threshold

bandCombinations.forEach(function(bands) {
  var classifiedImage = runModel(bands, trainGlaciers, testGlacier);
  var accuracy = accuracyList[accuracyList.length - 1].get('Accuracy'); // Get the last added accuracy
  accuracy = ee.Number(accuracy); // Convert to ee.Number for comparison

    classifiedImages.push(classifiedImage);
    validClassifications.push(bands.join(', ')); // Keep track of valid band combinations
});

//=======================================
// 4. Final Classification and Evaluation
//=======================================
if (classifiedImages.length > 0) {
  var combinedClassification = ee.ImageCollection.fromImages(classifiedImages).sum();

  // Display the final classification
  Map.centerObject(testRoi, 12);
  Map.addLayer(combinedClassification, {min:0, max:20, palette: jet}, 'Final Classification sum', false);
  
  //var classificationCollection = ee.ImageCollection(classifiedImages);
  //print('combinedClassification', combinedClassification);
  //print(classificationCollection.limit(10));

// 4.1 Calculate Otsu's threshold
/*
// Calculate the histogram
var histogram = combinedClassification.reduceRegion({
  reducer: ee.Reducer.histogram(),
  geometry: testRoi,
  scale: 30,  // Adjust scale to your resolution
  maxPixels: 1e13
});
var histInfo = ee.Dictionary(histogram.get('classification'));
var counts = ee.List(histInfo.get('histogram'));
var values = ee.List(histInfo.get('bucketMeans'));


// Extract histogram data
var histInfo = ee.Dictionary(histogram.get('classification'));
var counts = ee.List(histInfo.get('histogram'));
var values = ee.List(histInfo.get('bucketMeans'));

// Calculate total sum of pixels
var totalPixels = counts.reduce(ee.Reducer.sum());

// Function to calculate the weighted sum
var weightedSum = values.zip(counts).map(function(pair) {
  var value = ee.Number(ee.List(pair).get(0));
  var count = ee.Number(ee.List(pair).get(1));
  return value.multiply(count);
});

// Total weighted sum
var sumTotal = ee.Number(weightedSum.reduce(ee.Reducer.sum()));

// Helper function to calculate Otsu's threshold
var otsuThreshold = function(values, counts, totalPixels, sumTotal) {
  // Iterate over the values to find the optimal threshold
  var result = ee.List(values.iterate(function(value, prev) {
    var prevData = ee.Dictionary(prev);

    // Compute weights for the background and foreground
    var weightBackground = prevData.getNumber('weightBackground').add(ee.Number(counts.get(values.indexOf(value))));
    var weightForeground = ee.Number(totalPixels).subtract(weightBackground);

    // Skip this iteration if there's no foreground
    var mask = weightForeground.gt(0);

    var sumBackground = prevData.getNumber('sumBackground').add(ee.Number(value).multiply(ee.Number(counts.get(values.indexOf(value)))));
    var meanBackground = sumBackground.divide(weightBackground);
    var meanForeground = sumTotal.subtract(sumBackground).divide(weightForeground);

    // Compute between-class variance
    var variance = weightBackground.multiply(weightForeground).multiply(meanBackground.subtract(meanForeground).pow(2));

    // Compare variance to find the maximum
    var newMaxVariance = ee.Number(ee.Algorithms.If(
      variance.gt(prevData.get('maxVariance')),
      variance,
      prevData.get('maxVariance')
    ));

    var newThreshold = ee.Number(ee.Algorithms.If(
      variance.gt(prevData.get('maxVariance')),
      value,
      prevData.get('threshold')
    ));

    return ee.Dictionary({
      'maxVariance': newMaxVariance,
      'threshold': newThreshold,
      'weightBackground': weightBackground,
      'sumBackground': sumBackground
    });
  }, ee.Dictionary({
    'maxVariance': ee.Number(-1),
    'threshold': ee.Number(0),
    'weightBackground': ee.Number(0),
    'sumBackground': ee.Number(0)
  })));

  return ee.Number(ee.Dictionary(result).get('threshold'));
};

// Find the optimal Otsu threshold
var thr = otsuThreshold(values, counts, totalPixels, sumTotal);
print('Otsu Threshold:', thr);

thr = 19;
*/

//===============
// Region growing
//===============

// Compute the 90th percentile of the classification image within the ROI
/*
var percentile = combinedClassification.reduceRegion({
  reducer: ee.Reducer.percentile([90]),  
  geometry: buffers[testGlacier],
  scale: 30,
  bestEffort: true, 
  tileScale: 4,
  maxPixels: 1e8
});
*/
print('Image stats:', combinedClassification.reduceRegion({
  reducer: ee.Reducer.minMax(),
  geometry: testRoi,
  scale: 30,
  maxPixels: 1e9
}));


var percentile = combinedClassification.reduceRegion({
  reducer: ee.Reducer.percentile([90]), 
  geometry: testRoi, 
  scale: 30, 
  //crs: 'EPSG:4326',
  maxPixels: 1e9
});


// Extract the threshold value
var seedThreshold = ee.Number(percentile.get('classification'));  // Adjust band name if needed
print('seed thr', seedThreshold);
seedThreshold = seedThreshold.subtract(1);

// Create a dynamic seed mask: Pixels >= 90th percentile are used as seeds
var adaptiveSeeds = combinedClassification.gte(seedThreshold).selfMask();

var seedMask = combinedClassification.gte(seedThreshold);

// Convert seed mask to binary mask (selfMask removes 0 values)
var seeds = seedMask.selfMask(); 
seeds = seeds.unmask(0).clip(testRoi);  // Convert no-data areas to 0

print('seeds', seeds);
Map.addLayer(seeds, {min: 0, max: 1, palette: ['white', 'green']}, '90%', false);



// Add to map

var extended = seeds.focalMax(1, 'square', 'pixels');
Map.addLayer(extended, {palette: ['white', 'red']}, 'extended', false);
var eroded = extended.focalMin(1, 'square', 'pixels');
Map.addLayer(eroded, {palette: ['white', 'blue']}, 'eroded', false);

var smoothed = eroded.focalMode({
  radius: 1,      // 3x3 window (radius of 1 pixel)
  kernelType: 'square',  
  units: 'pixels' // Only assign the majority value if at least 5 out of 9 pixels have it
});
Map.addLayer(smoothed, {palette: ['white', 'pink']}, 'Smoothed Mask', false);

var finalClassification = smoothed;

/*
// Define the threshold for growing
var threshold = 0;  // Adjust as needed

// Function to expand glacier mask iteratively
function regionGrow(img, seedMask, threshold) {
    var prevMask = seedMask;  // Start with seed pixels
    var growing = true;  // Flag to track changes
    Map.addLayer(prevMask.focalMax(1, 'square', 'pixels'), {palette: ['red']}, 'Neighbors');

    // Define a function for one iteration of region growing
    function growStep(currentMask) {
        // Find neighboring pixels
        var neighbors = currentMask.focalMax(2, 'square', 'pixels');
        //var neighbors = currentMask.connectedComponents(ee.Kernel.plus(1), 256);


        var img = combinedClassification.unmask();

        // Select new pixels where value ≥ threshold
        //var newMask = img.gte(threshold).updateMask(neighbors);
        //var newMask = neighbors.updateMask(img);
        var newMask = img.updateMask(neighbors);

        print('NewMask Pixels:', newMask.reduceRegion({
    reducer: ee.Reducer.count(),
    geometry: buffers[testGlacier],
    scale: 30,
    maxPixels: 1e9
}));

       // Merge with the previous mask
       // var updatedMask = currentMask.or(newMask);
        var updatedMask = currentMask.where(newMask, 1);

        return updatedMask;
    }
    
    // Iterate multiple times (region growing)
    for (var i = 0; i < 100; i++) { // Adjust iteration count as needed
        var newMask = growStep(prevMask);
        
        // Check if the mask has changed
        var diff = newMask.neq(prevMask);
        
        var hasNewPixels = diff.reduceRegion({
            reducer: ee.Reducer.anyNonZero(),
            geometry: buffers[testGlacier],//img.geometry(),
            scale: 30,
            maxPixels: 1e9
        }).values().get(0);
        print('New pixels in iteration:', i, hasNewPixels);
        
        var hasNewPixels = diff.reduceRegion({
          reducer: ee.Reducer.anyNonZero(),
          geometry: buffers[testGlacier],
          scale: 30,
          maxPixels: 1e9,
          tileScale: 4
        }).values().get(0);

//print('New pixels in iteration:', i, hasNewPixels);
print('Iteration:', i, 
    'PrevMask Pixels:', prevMask.reduceRegion({
        reducer: ee.Reducer.count(),
        geometry: buffers[testGlacier],
        scale: 30,
        maxPixels: 1e9
    }), 
    'NewMask Pixels:', newMask.reduceRegion({
        reducer: ee.Reducer.count(),
        geometry: buffers[testGlacier],
        scale: 30,
        maxPixels: 1e9
    })
);


        if (hasNewPixels === null || hasNewPixels === 0) {
         growing = false;
         break;
        }
        
if (!hasNewPixels || hasNewPixels === 0) { 
    print('Stopping at iteration:', i);
    break;
}
prevMask = prevMask.or(newMask);  // Merge old and new pixels

       // prevMask = newMask;
    }
    return prevMask;
}

// Apply region growing
var glacierMask = regionGrow(combinedClassification, seeds, threshold);
print('glacierMask', glacierMask);
Map.addLayer(glacierMask.select('classification'), {palette: ['cyan']}, 'Detected Glacier');

var finalClassification = glacierMask;
*/

// 4.2 Apply the threshold to the final classification sum
  // Threshold the combined classification to obtain final classification
 // var finalClassification = combinedClassification.where(combinedClassification.lt(thr), 0).where(combinedClassification.gte(thr), 1);
  //print('Final Classification', finalClassification);

  // Stratified sampling to compare classification and ground truth
  var testSamplesFinal = finalClassification.addBands(maskedTestGroundTruth).stratifiedSample({
      numPoints: 2000,
      classBand: 'class',
      region: buffers[testGlacier],
      scale: 30,
      geometries: true
  });

  // Confusion matrix and accuracy
  var validationSampleFinal = testSamplesFinal.errorMatrix('class', 'classification');
  var accuracyFinal = validationSampleFinal.accuracy();
  //print('Error Matrix Final:', validationSampleFinal);
  //print('Accuracy Final:', accuracyFinal);

// Extract confusion matrix elements
var confusionMatrix = validationSampleFinal.array();
var TP = confusionMatrix.get([1, 1]); // True Positives (Debris correctly identified)
var FP = confusionMatrix.get([0, 1]); // False Positives (Non-debris misclassified as debris)
var FN = confusionMatrix.get([1, 0]); // False Negatives (Debris missed)
var TN = confusionMatrix.get([0, 0]); // True Negatives (Non-debris correctly classified)

// Compute Precision: TP / (TP + FP)
var precision = TP.divide(TP.add(FP));

// Compute Recall (Sensitivity): TP / (TP + FN)
var recall = TP.divide(TP.add(FN));

// Compute F1-Score: 2 * (Precision * Recall) / (Precision + Recall)
var f1Score = precision.multiply(recall).multiply(2).divide(precision.add(recall));


// Add Metrics to Summary
var evaluationMetrics = ee.Feature(null, {
  'Accuracy': accuracyFinal,
  'F1-Score': f1Score,
  'Precision': precision,
  'Recall': recall,
  //'TP':TP,
  //'FP':FP,
  //'FN':FN,
  //'TN':TN
});
print('evaluations metrics', evaluationMetrics);


/*
  accuracyList.push(ee.Feature(null, {
    'Final Accuracy': accuracyFinal
  }));

  var accuracyTable = ee.FeatureCollection(accuracyList);
  //print('Accuracy Table', accuracyTable);
*/
  //Map.addLayer(finalClassification, visClass, 'Final Classification mask');

//==================================================
// 5. Smooth and vectorize final classification mask
//==================================================

// Apply a majority filter to smooth the classified image
var kernel = ee.Kernel.square({radius: 2});
var smoothedClassification = finalClassification.reduceNeighborhood({
  reducer: ee.Reducer.mode(),
  kernel: kernel
});

// Display the classified image
//Map.addLayer(smoothedClassification, {min: 0, max: 1, palette: ['white', 'black']}, 'Smoothed Classified Image');

// Select the relevant band
var classificationBand = smoothedClassification.select('classification_mode');

// Threshold the image to create a binary mask where 1's are kept
var mask = classificationBand.eq(1);
mask = mask.updateMask(mask);

// Convert the binary mask to vectors (polygons)
var polygons = mask.reduceToVectors({
  geometryType: 'polygon',
  reducer: ee.Reducer.countEvery(),
  scale: 30,  // Adjust to your image's resolution
  maxPixels: 1e8,
  geometry: testRoi  // Ensure the geometry of the mask is used
});

Map.addLayer(testInput, {bands: 'coherence'}, 'coherence', false);

//Map.addLayer(zmutt_2015, {}, 'zmutt 2015');
//Map.addLayer(oberaletsch_2014, {}, 'oberaletsch 2014');

// Add the vector layer to the map to visualize the polygons
//Map.addLayer(testInput, {bands: 'inSAR'}, 'inSAR', false);
Map.addLayer(testInput, {bands: 'normalizedLst'}, 'normalizedLst', false);
Map.addLayer(rgi7, {color: 'violet'}, 'rgi 7.0');
Map.addLayer(polygons, {color: 'red'}, 'Vectorized classification result', false);

var simplifiedFC = polygons.map(function(feature) {
    return feature.simplify(50);  // Adjust tolerance as needed
});

Map.addLayer(simplifiedFC, {color: 'lightblue'}, 'Simplified Polygons');

// for belvedere:
Map.addLayer(belvedere18, {color: 'blue'}, 'belvedere 2018', false);
Map.addLayer(belvedere21, {color: 'blue'}, 'belvedere 2021', false);
Map.addLayer(belvedere23, {color: 'blue'}, 'belvedere 2023', false);

// for satopanth: 
Map.addLayer(satopanth_tongue_2017, {color: 'blue'}, 'satopanth 2017', false);

// Print the polygons to the console for inspection
//print('vectorized classification result', polygons);

/*
// alternative methods for thresholding
var dataset = combinedClassification;

// 2. Adaptive Thresholding using Local Mean (Focal Statistics)
var kernel = ee.Kernel.square(20);  // Neighborhood size
var localMean = dataset.reduceNeighborhood({
  reducer: ee.Reducer.mean(),
  kernel: kernel
});

var adaptiveThreshold = dataset.gt(localMean);
Map.addLayer(adaptiveThreshold, {palette: ['black', 'red']}, 'Adaptive Threshold');

// 3. K-means Clustering for Glacier Segmentation
var training = dataset.sample({
  region: testRoi,
  scale: 30,
  numPixels: 5000
});

var clusterer = ee.Clusterer.wekaKMeans(2).train(training);
var clustered = dataset.cluster(clusterer);
Map.addLayer(clustered.randomVisualizer(), {}, 'K-means Clustering');

// 4. Morphological Operations for Smoothing
var binaryMask = adaptiveThreshold
  .focalMode({radius: 1, kernelType: 'square'}) // Smooth small noise
  .focalMax({radius: 1, kernelType: 'circle'})  // Fill gaps
  .selfMask();  // Remove zero pixels

Map.addLayer(binaryMask, {palette: ['black', 'cyan']}, 'Morphologically Processed');

*/
//==========
// 6. Export
//==========

Export.table.toDrive({
  collection: polygons,
  description:'vectorized_'+testGlacier+selectedYear,
  folder: 'DCG_approachII_GEE_exports',
  fileFormat: 'KML'
});
/*
Export.image.toDrive({
  image: finalClassification.toDouble(),
  description: 'finalClassification_approachII_' + testGlacier+selectedYear,
  folder: 'DCG_approachII_GEE_exports',
  scale: 30,
  region: testRoi,
  fileFormat: 'GeoTIFF'
});
Export.image.toDrive({
  image: combinedClassification.toDouble(),
  description: 'combinedClassification_approachII_' + testGlacier+selectedYear,
  folder: 'DCG_approachII_GEE_exports',
  scale: 30,
  region: testRoi,
  fileFormat: 'GeoTIFF'
});
Export.image.toDrive({
  image: testInput.toDouble(),
  description: 'testInput_' + testGlacier+selectedYear,
  folder: 'DCG_approachII_GEE_exports',
  scale: 30,
  region: testRoi,
  fileFormat: 'GeoTIFF'
});
Export.table.toDrive({
  collection: accuracyTable,
  description: 'accuracyTable_differentGlaciers_'+testGlacier+selectedYear, 
  folder: 'DCG_approachII_GEE_exports', 
  fileFormat: 'CSV'});
*/

} 
