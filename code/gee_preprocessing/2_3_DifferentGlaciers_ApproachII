/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var poi_zmutt = 
    /* color: #0b4a8b */
    /* shown: false */
    ee.Geometry.Point([7.642595783012829, 46.00088355131704]),
    poi_oberaletsch = 
    /* color: #0b4a8b */
    /* shown: false */
    ee.Geometry.Point([7.969479269132309, 46.42247658348475]),
    poi_unteraar = 
    /* color: #ffc82d */
    /* shown: false */
    ee.Geometry.Point([8.18837776104397, 46.57109412065738]),
    roi_unteraar = 
    /* color: #00ffff */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[8.093277358211939, 46.605423677609075],
          [8.093277358211939, 46.52894816125691],
          [8.286568068661158, 46.52894816125691],
          [8.286568068661158, 46.605423677609075]]], null, false),
    unteraar_gT_polygon = 
    /* color: #98ff00 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[8.258587264217878, 46.565405834410505],
          [8.255840682186628, 46.572014645501696],
          [8.233181380428816, 46.570834559720566],
          [8.223911666073347, 46.570834559720566],
          [8.208805464901472, 46.57673473186028],
          [8.18786277691319, 46.5774427093805],
          [8.156963729061628, 46.599149531830086],
          [8.147350691952253, 46.58664557598989],
          [8.16039695660069, 46.572486672624684],
          [8.175846480526472, 46.56753018293315],
          [8.156963729061628, 46.554546753810335],
          [8.130871199764753, 46.573430714545886],
          [8.118511580624128, 46.56611395982841],
          [8.155247115292097, 46.53825405787602],
          [8.16417350689366, 46.53825405787602],
          [8.19610252300694, 46.55903228968079],
          [8.225628279842878, 46.55667152754723]]]),
    zmutt_gT_polygon = 
    /* color: #00ffff */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[7.6625092885442125, 46.00139938073074],
          [7.6570161244817125, 46.004976554975336],
          [7.6453431508489, 46.00449961177317],
          [7.6322968862004625, 46.00187635066049],
          [7.626460399384056, 46.0023533164783],
          [7.6199372670598375, 46.00759966908666],
          [7.629893626923119, 46.01236864879793],
          [7.6233704945989, 46.01737563495285],
          [7.607234325165306, 46.01713721732037],
          [7.605517711395775, 46.00116089422388],
          [7.6089509389348375, 45.99543690966295],
          [7.6116975209660875, 45.99400582100345],
          [7.6020844838567125, 45.98661127337282],
          [7.607234325165306, 45.982317211721835],
          [7.614787425751244, 45.97993147799447],
          [7.628520335907494, 45.980408632964014],
          [7.631953563446556, 45.982317211721835],
          [7.635730113739525, 45.989235258192736],
          [7.639506664032494, 45.99114353266096],
          [7.657359447235619, 45.99329026279577]]]),
    oberaletsch_gT_polygon = 
    /* color: #bf04c2 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[7.9640601590144655, 46.414936956365],
          [7.976763100908997, 46.40972936809718],
          [7.990496011065247, 46.40310080932459],
          [8.003542275713684, 46.400970030089226],
          [8.008005471514466, 46.40381105057684],
          [8.008348794268372, 46.40925592632512],
          [7.9997657254207155, 46.4156470435118],
          [7.987062783526184, 46.42109073779113],
          [7.9819129422175905, 46.4246406803959],
          [7.987062783526184, 46.4317398721506],
          [7.991869302080872, 46.43931132424458],
          [7.990496011065247, 46.44451608733249],
          [7.985346169756653, 46.44853760916607],
          [7.979509682940247, 46.45918138094234],
          [7.973329873369934, 46.462255861057976],
          [7.957880349444153, 46.46178287541715],
          [7.9558204129207155, 46.456343245205126],
          [7.960626931475403, 46.44640860517826],
          [7.9681800320613405, 46.44049426860716],
          [7.956850381182434, 46.428663669244216],
          [7.9448340847957155, 46.438838139308366],
          [7.928011269854309, 46.43576233705923],
          [7.914965005205872, 46.42582394323029],
          [7.913935036944153, 46.42038072153179],
          [7.920458169268372, 46.41754056403283],
          [7.931444497393372, 46.41919734055254],
          [7.935564370440247, 46.42038072153179],
          [7.9517005398738405, 46.40830903045258],
          [7.963373513506653, 46.405941718855146],
          [7.966463418291809, 46.40972936809718]]]),
    roi_oberaletsch = 
    /* color: #ff0000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[7.912561745928528, 46.462610294473386],
          [7.912561745928528, 46.398720480474125],
          [8.012468667315247, 46.398720480474125],
          [8.012468667315247, 46.462610294473386]]], null, false),
    groundTruth_zmutt_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_zmutt2003"),
    groundTruth_zmutt_2010 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_zmutt2010"),
    groundTruth_zmutt_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_zmutt2016"),
    rf_input_zmutt_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/image_allBands_fromScript_zmutt2003"),
    rf_input_zmutt_2010 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/image_allBands_fromScript_zmutt2010"),
    rf_input_zmutt_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/image_allBands_fromScript_zmutt2016"),
    roi_zmutt = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[7.599852885957441, 46.01744963942263],
          [7.599852885957441, 45.97761969922328],
          [7.661650981660566, 45.97761969922328],
          [7.661650981660566, 46.01744963942263]]], null, false),
    groundTruth_oberaletsch_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_oberaletsch2003"),
    groundTruth_oberaletsch_2010 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_oberaletsch2010"),
    groundTruth_oberaletsch_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_oberaletsch2016"),
    groundTruth_unteraar_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_unteraar2003"),
    groundTruth_unteraar_2010 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_unteraar2010"),
    groundTruth_unteraar_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_unteraar2016"),
    rf_input_oberaletsch_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/image_allBands_fromScript_oberaletsch2003"),
    rf_input_oberaletsch_2010 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/image_allBands_fromScript_oberaletsch2010"),
    rf_input_oberaletsch_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/image_allBands_fromScript_oberaletsch2016"),
    rf_input_unteraar_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/image_allBands_fromScript_unteraar2003"),
    rf_input_unteraar_2010 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/image_allBands_fromScript_unteraar2010"),
    rf_input_unteraar_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/image_allBands_fromScript_unteraar2016"),
    rf_input_belvedere_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/image_allBands_fromScript_belvedere2003"),
    groundTruth_belvedere_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_belvedere2003"),
    roi_belvedere = 
    /* color: #98ff00 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[7.882228685119119, 45.97116574008611],
          [7.882228685119119, 45.929153352388795],
          [7.9320104844355255, 45.929153352388795],
          [7.9320104844355255, 45.97116574008611]]], null, false),
    rf_input_satopanth_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/image_allBands_fromScript_satopanth2003"),
    rf_input_satopanth_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/image_allBands_fromScript_satopanth2016"),
    groundTruth_satopanth_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/single_scenes_regression_new/groundTruth_satopanth2003"),
    roi_satopanth = 
    /* color: #0b4a8b */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[79.26526797759985, 30.816163937992354],
          [79.26526797759985, 30.729438686838353],
          [79.42868960845922, 30.729438686838353],
          [79.42868960845922, 30.816163937992354]]], null, false);
/***** End of imports. If edited, may not auto-convert in the playground. *****/
/*
Refining Debris-Covered Glacier Outlines Using Land Surface Temperature Data
MSc Thesis Lorena Müller

Different Glaciers Approach II

 In this script, the input layers for the random forest classification are imported and the classification 
 is performed for one year at a time. Two glaciers are used for training and a third one for testing. 
 The classifier loops through 20 randomly generated band combinations. The results of these 20 classifications
 are combined in a single final image. 
 RGI 7.0 glacier outlines (including snow/ice) are included as one of the input layers. 

 Contents
 1. Initialization and Imports          // choose year of interest and glaciers for training and testing
 2. Prepare Training Data and Classification
 3. Loop Through Band Combinations
 4. Final Classification and Evaluation
 5. Smooth and vectorize final classification mask
 6. Export
 
*/

//=======================================
// 1. Initialization and Imports
//=======================================

// Define the year for which to run the classification (2003, 2010, or 2016)
var selectedYear = 2016;                // Choose between 2010 and 2016

// Define the glaciers to use for training and testing
var trainGlacier1 = 'unteraar';  
var trainGlacier2 = 'oberaletsch';
var testGlacier = 'zmutt';           // Choose between zmutt, unteraar or oberaletsch. Adjust training glcaiers accordingly. 
                                        // For Belvedere and Satopanth, statistical validation is not possible with this approach.

var trainGlaciers = [trainGlacier1, trainGlacier2];

// Define bands to use for classification
var bands = [ 'lstNir', 'ndri', 'lstNir_superPixelMeans','edges', 'smooth',  'ndwi', 'ndsi', 'ndvi', 'slope',  'aspect', 'elevation', 'gradient', 'TPI','glacierInventory'];

var palettes = require('users/gena/packages:palettes');
var jet = palettes.misc.jet[7];
var visClass = {min: 0, max: 1, palette: ['white', 'black']};
var blueToRed = palettes.colorbrewer.RdYlBu[11];

// Define the glacier input data as a dictionary
var glaciers = {
  'zmutt': {
    roi: roi_zmutt,
    input2003: rf_input_zmutt_2003,
    input2010: rf_input_zmutt_2010,
    input2016: rf_input_zmutt_2016,
    groundTruth2003: groundTruth_zmutt_2003,
    groundTruth2010: groundTruth_zmutt_2010,
    groundTruth2016: groundTruth_zmutt_2016,
    gT_polygon: zmutt_gT_polygon 
  },
  'unteraar': {
    roi: roi_unteraar,
    input2003: rf_input_unteraar_2003,
    input2010: rf_input_unteraar_2010,
    input2016: rf_input_unteraar_2016,
    groundTruth2003: groundTruth_unteraar_2003,
    groundTruth2010: groundTruth_unteraar_2010,
    groundTruth2016: groundTruth_unteraar_2016,
    gT_polygon: unteraar_gT_polygon 
  },
  'oberaletsch': {
    roi: roi_oberaletsch,
    input2003: rf_input_oberaletsch_2003,
    input2010: rf_input_oberaletsch_2010,
    input2016: rf_input_oberaletsch_2016,
    groundTruth2003: groundTruth_oberaletsch_2003,
    groundTruth2010: groundTruth_oberaletsch_2010,
    groundTruth2016: groundTruth_oberaletsch_2016,
    gT_polygon: oberaletsch_gT_polygon 
  },
  'belvedere':{
    roi: roi_belvedere,
    input2003: rf_input_belvedere_2003,
    input2010: rf_input_belvedere_2003,
    input2016: rf_input_belvedere_2003,
    groundTruth2003: groundTruth_belvedere_2003,
    groundTruth2010: groundTruth_belvedere_2003,
    groundTruth2016: groundTruth_belvedere_2003,
    gT_polygon: roi_belvedere
  },
  'satopanth':{
    roi: roi_satopanth,
    input2003: rf_input_satopanth_2003,
    input2010: rf_input_satopanth_2003,
    input2016: rf_input_satopanth_2016,
    groundTruth2003: groundTruth_satopanth_2003,
    groundTruth2010: groundTruth_satopanth_2003,
    groundTruth2016: groundTruth_satopanth_2003,
    gT_polygon: roi_satopanth 
  }
};

// Glacier inventory for 2003, to be used for all years in Approach II
var glacierInventory2003 = {
  'zmutt': glaciers['zmutt'].input2003.select('glacierInventory'),
  'unteraar': glaciers['unteraar'].input2003.select('glacierInventory'),
  'oberaletsch': glaciers['oberaletsch'].input2003.select('glacierInventory'),
  'belvedere': glaciers['belvedere'].input2003.select('glacierInventory'),
  'satopanth': glaciers['satopanth'].input2003.select('glacierInventory')
};

// Function to get the correct input and ground truth based on the selected year
function getInputAndGroundTruth(glacierData, year, glacierName) {
  var input, groundTruth;
  
  if (year === 2003) {
    input = glacierData.input2003;
    groundTruth = glacierData.groundTruth2003;
  } else if (year === 2010) {
    input = glacierData.input2010;
    groundTruth = glacierData.groundTruth2010;
    // Replace glacierInventory with the one from 2003
    input = input.addBands(glacierInventory2003[glacierName], null, true);  // true to overwrite
  } else {
    input = glacierData.input2016;
    groundTruth = glacierData.groundTruth2016;
    // Replace glacierInventory with the one from 2003
    input = input.addBands(glacierInventory2003[glacierName], null, true);  // true to overwrite
  }
  
  return {
    input: input,
    groundTruth: groundTruth
  };
}

// Load glacier data for the test glacier
var testGlacierData = glaciers[testGlacier];
var testInputAndGT = getInputAndGroundTruth(testGlacierData, selectedYear, testGlacier);  // Pass glacierName as third argument
var testInput = testInputAndGT.input;
var testGroundTruth = testInputAndGT.groundTruth;
var testRoi = testGlacierData.roi;

// Mask Ground Truth data using the polygon
function maskGroundTruth(groundTruth, polygon) {
  var clippedGT = groundTruth//.clip(polygon);
  var maskedGT = groundTruth.where(clippedGT.mask().not(), 0);
  return maskedGT;
}

var maskedTestGroundTruth = maskGroundTruth(testGroundTruth, testGlacierData.gT_polygon);

// Apply mask to the ground truth for each glacier
var maskedGroundTruths = {
  'unteraar': maskGroundTruth(getInputAndGroundTruth(glaciers['unteraar'], selectedYear, 'unteraar').groundTruth, glaciers['unteraar'].gT_polygon),
  'oberaletsch': maskGroundTruth(getInputAndGroundTruth(glaciers['oberaletsch'], selectedYear, 'oberaletsch').groundTruth, glaciers['oberaletsch'].gT_polygon),
  'zmutt': maskGroundTruth(getInputAndGroundTruth(glaciers['zmutt'], selectedYear, 'zmutt').groundTruth, glaciers['zmutt'].gT_polygon),
  'belvedere': maskGroundTruth(getInputAndGroundTruth(glaciers['belvedere'], selectedYear, 'belvedere').groundTruth, glaciers['belvedere'].gT_polygon),
  'satopanth': maskGroundTruth(getInputAndGroundTruth(glaciers['satopanth'], selectedYear, 'satopanth').groundTruth, glaciers['satopanth'].gT_polygon)
};

var updatedInputs = {
  'unteraar': getInputAndGroundTruth(glaciers['unteraar'], selectedYear, 'unteraar').input,
  'oberaletsch': getInputAndGroundTruth(glaciers['oberaletsch'], selectedYear, 'oberaletsch').input,
  'zmutt': getInputAndGroundTruth(glaciers['zmutt'], selectedYear, 'zmutt').input,
  'belvedere': getInputAndGroundTruth(glaciers['belvedere'], selectedYear, 'belvedere').input,
  'satopanth': getInputAndGroundTruth(glaciers['satopanth'], selectedYear, 'satopanth').input
};

Map.addLayer(maskedGroundTruths[testGlacier], visClass, 'Ground Truth ' + selectedYear);



//Define band combinations
// Band combinations: 20 combinations with 7-9 input layers per combination
/*
var bandCombinations = [
  ['lstNir', 'ndvi', 'TPI', 'lstNir_superPixelMeans', 'slope', 'ndwi', 'edges', 'elevation'],
  ['ndvi', 'lstNir_superPixelMeans', 'slope', 'gradient', 'aspect', 'glacierInventory', 'ndsi'],
  ['lstNir', 'ndwi', 'TPI', 'smooth', 'slope', 'elevation', 'ndsi', 'ndvi', 'ndri'],
  ['edges', 'lstNir_superPixelMeans', 'glacierInventory', 'gradient', 'aspect', 'ndvi', 'TPI', 'slope'],
  ['lstNir', 'ndsi', 'slope', 'aspect', 'ndwi', 'lstNir_superPixelMeans'],
  ['ndvi', 'lstNir', 'TPI', 'lstNir_superPixelMeans', 'slope', 'ndsi', 'ndri', 'smooth', 'edges'],
  ['lstNir', 'ndwi', 'TPI', 'slope', 'gradient', 'glacierInventory', 'smooth'],
  ['ndri', 'lstNir_superPixelMeans', 'ndsi', 'ndvi', 'edges', 'slope', 'aspect', 'elevation'],
  ['lstNir', 'ndvi', 'ndwi', 'slope', 'gradient', 'smooth', 'lstNir_superPixelMeans', 'glacierInventory'],
  ['edges', 'lstNir', 'TPI', 'smooth', 'elevation', 'ndvi', 'ndsi', 'ndri', 'slope'],
  ['lstNir_superPixelMeans', 'ndvi', 'ndri', 'glacierInventory', 'ndsi', 'edges', 'slope'],
  ['ndwi', 'lstNir', 'TPI', 'gradient', 'aspect', 'slope', 'lstNir_superPixelMeans', 'ndsi'],
  ['lstNir_superPixelMeans', 'ndvi', 'smooth', 'elevation', 'ndwi', 'edges', 'ndsi'],
  ['ndsi', 'lstNir', 'ndvi', 'slope', 'TPI', 'lstNir_superPixelMeans', 'aspect', 'gradient'],
  ['lstNir', 'glacierInventory', 'edges', 'elevation', 'ndwi', 'smooth', 'TPI', 'ndvi'],
  ['ndvi', 'ndsi', 'lstNir_superPixelMeans', 'gradient', 'aspect', 'edges', 'slope', 'elevation'],
  ['lstNir', 'ndwi', 'lstNir_superPixelMeans', 'glacierInventory', 'slope', 'ndsi', 'TPI'],
  ['edges', 'lstNir', 'TPI', 'smooth', 'elevation', 'ndwi', 'gradient', 'ndri', 'glacierInventory'],
  ['lstNir_superPixelMeans', 'ndsi', 'lstNir', 'ndwi', 'elevation', 'smooth', 'edges', 'ndri'],
  ['ndvi', 'lstNir_superPixelMeans', 'lstNir', 'glacierInventory', 'slope', 'aspect', 'TPI', 'ndsi', 'edges']
];
*/
// Band combinations: 20 combinations with 5-6 input layers per combination

var bandCombinations = [
  ['lstNir', 'ndvi', 'TPI', 'lstNir_superPixelMeans', 'slope'],
  ['ndwi', 'edges', 'ndsi', 'lstNir', 'glacierInventory'],
  ['lstNir_superPixelMeans', 'ndri', 'smooth', 'ndvi', 'TPI', 'elevation'],
  ['ndvi', 'lstNir', 'ndwi', 'slope', 'aspect', 'gradient'],
  ['edges', 'smooth', 'lstNir_superPixelMeans', 'ndsi', 'TPI', 'glacierInventory'],
  ['lstNir', 'ndvi', 'slope', 'elevation', 'ndri'],
  ['ndwi', 'edges', 'TPI', 'lstNir_superPixelMeans', 'glacierInventory'],
  ['lstNir_superPixelMeans', 'ndsi', 'ndvi', 'gradient', 'smooth'],
  ['lstNir', 'TPI', 'smooth', 'slope', 'ndwi', 'elevation'],
  ['ndri', 'lstNir', 'edges', 'glacierInventory', 'ndvi'],
  ['lstNir_superPixelMeans', 'ndwi', 'slope', 'TPI', 'gradient', 'elevation'],
  ['ndvi', 'lstNir', 'smooth', 'edges', 'glacierInventory'],
  ['lstNir', 'TPI', 'ndsi', 'smooth', 'elevation'],
  ['glacierInventory', 'lstNir_superPixelMeans', 'ndri', 'edges', 'slope'],
  ['ndwi', 'lstNir', 'TPI', 'smooth', 'ndvi'],
  ['lstNir_superPixelMeans', 'edges', 'ndsi', 'slope', 'elevation'],
  ['ndvi', 'lstNir', 'TPI', 'glacierInventory', 'gradient'],
  ['lstNir', 'ndwi', 'smooth', 'ndri', 'slope'],
  ['edges', 'lstNir_superPixelMeans', 'ndvi', 'TPI', 'glacierInventory'],
  ['lstNir', 'ndsi', 'slope', 'elevation', 'ndri']
];

/*
var bandCombinations = [
  ['ndvi', 'TPI', 'slope', 'ndwi', 'ndsi'],
  ['glacierInventory', 'ndri', 'elevation', 'aspect', 'gradient'],
  ['ndvi', 'ndsi', 'TPI', 'slope', 'glacierInventory'],
  ['ndwi', 'ndri', 'elevation', 'gradient', 'TPI'],
  ['slope', 'aspect', 'ndsi', 'glacierInventory', 'ndvi'],
  ['TPI', 'ndri', 'ndwi', 'slope', 'elevation'],
  ['gradient', 'glacierInventory', 'ndsi', 'ndvi', 'ndri'],
  ['ndwi', 'TPI', 'aspect', 'slope', 'glacierInventory'],
  ['ndsi', 'ndri', 'elevation', 'gradient', 'ndvi'],
  ['slope', 'TPI', 'ndwi', 'glacierInventory', 'aspect'],
  ['ndri', 'ndvi', 'ndsi', 'gradient', 'slope'],
  ['glacierInventory', 'ndwi', 'TPI', 'elevation', 'ndsi'],
  ['aspect', 'ndri', 'slope', 'gradient', 'ndvi'],
  ['ndsi', 'ndwi', 'TPI', 'slope', 'glacierInventory'],
  ['ndri', 'elevation', 'gradient', 'ndvi', 'aspect'],
  ['TPI', 'ndsi', 'slope', 'glacierInventory', 'ndvi'],
  ['ndwi', 'ndri', 'elevation', 'gradient', 'slope'],
  ['ndsi', 'glacierInventory', 'ndvi', 'aspect', 'TPI'],
  ['ndri', 'slope', 'ndwi', 'elevation', 'glacierInventory'],
  ['TPI', 'gradient', 'ndsi', 'ndvi', 'ndri']
];
*/


// Visualization parameters
var visClass = {min: 0, max: 1, palette: ['white', 'black']};

// Array to store band combinations and validation accuracies
var accuracyList = [];

//=======================================
// 2. Prepare Training Data and Classification
//=======================================

// Function to train a classifier, classify, and evaluate accuracy
function runModel(bands, trainGlaciers, testGlacier) {

  // 2.1 Prepare training data for the selected glaciers
  function prepareTrainingData(glacier, input, groundTruth, bands, region) {
    return input.select(bands).addBands(groundTruth).stratifiedSample({
      numPoints:  3000,
      classBand: 'class',
      region: region,
      scale: 30,
      geometries: true
    });
  }

  var trainingData = trainGlaciers.reduce(function(data, glacier) {
    var glacierData = glaciers[glacier];
    var glacierTrainingData = prepareTrainingData(glacier, updatedInputs[glacier], maskedGroundTruths[glacier], bands, glacierData.roi);
    return data.merge(glacierTrainingData);
  }, ee.FeatureCollection([]));
  
  // 2.2 Balance training data (oversampling)
  var class0 = trainingData.filter(ee.Filter.eq('class', 0));  // Non-DCG
  var class1 = trainingData.filter(ee.Filter.eq('class', 1));  // DCG

  // Oversample the minority class (debris)
  function oversample(minorityClass, targetSize) {
    var minorityCount = minorityClass.size();
    var replicationFactor = targetSize.divide(minorityCount).ceil();
    var replicated = ee.FeatureCollection(ee.List.sequence(0, replicationFactor.subtract(1))
      .map(function(i) { return minorityClass; }))
      .flatten();
    return replicated.randomColumn().limit(targetSize);
  }

  var maxClassSize = class0.size();
  var replicatedClass1 = oversample(class1, maxClassSize);
  var balancedDataset = class0.merge(replicatedClass1);

  // 2.3 Train classifier on the training data
  var classifier = ee.Classifier.smileRandomForest(50).train({
    features: balancedDataset,
    classProperty: 'class',
    inputProperties: bands
  });

  // 2.4 Apply classifier to the testGlacier input
  var classifiedTestGlacier = testInput.select(bands).classify(classifier);

  // 2.5 Sample test data from classified image and ground truth
  var testSamples = classifiedTestGlacier.addBands(maskedTestGroundTruth)
    .stratifiedSample({
      numPoints: 2000,
      classBand: 'class',
      region: testRoi,
      scale: 30,
      geometries: true
    });

  // 2.6 Evaluate the classifier
  var validationSample = testSamples.errorMatrix('class', 'classification');
  var accuracy = validationSample.accuracy();
  var results = classifier.explain();

  // Add accuracy and bands to the list
  accuracyList.push(ee.Feature(null, {
    'Bands': bands.join(', '), 
    'Accuracy': accuracy,
    'importance':results.get('importance')
  }));

  return classifiedTestGlacier; // Return the classified image for mapping
}
//print('trainingData', trainingData);

//=======================================
// 3. Loop Through Band Combinations
//=======================================
var classifiedImages = []; // Array to store classified images
var validClassifications = []; // Array to store valid classified images based on accuracy threshold

bandCombinations.forEach(function(bands) {
  var classifiedImage = runModel(bands, trainGlaciers, testGlacier);
  var accuracy = accuracyList[accuracyList.length - 1].get('Accuracy'); // Get the last added accuracy
  accuracy = ee.Number(accuracy); // Convert to ee.Number for comparison

  
  classifiedImages.push(classifiedImage);
  validClassifications.push(bands.join(', ')); // Keep track of valid band combinations
    //Map.addLayer(classifiedImage, visClass, 'Classification ' + bands.join(', ')); // Visualisation of classification result of each band combination
  
});

//=======================================
// 4. Final Classification and Evaluation
//=======================================
if (classifiedImages.length > 0) {
  var combinedClassification = ee.ImageCollection.fromImages(classifiedImages).sum();
  //var classificationCollection = ee.ImageCollection(classifiedImages);
  //print('combinedClassification', combinedClassification);
  //print(classificationCollection.limit(10));

// 4.1 Calculate Otsu's threshold

// Calculate the histogram
var histogram = combinedClassification.reduceRegion({
  reducer: ee.Reducer.histogram(),
  geometry: testRoi,
  scale: 30,  // Adjust scale to your resolution
  maxPixels: 1e13
});

// Extract histogram data
var histInfo = ee.Dictionary(histogram.get('classification'));
var counts = ee.List(histInfo.get('histogram'));
var values = ee.List(histInfo.get('bucketMeans'));

// Calculate total sum of pixels
var totalPixels = counts.reduce(ee.Reducer.sum());

// Function to calculate the weighted sum
var weightedSum = values.zip(counts).map(function(pair) {
  var value = ee.Number(ee.List(pair).get(0));
  var count = ee.Number(ee.List(pair).get(1));
  return value.multiply(count);
});

// Total weighted sum
var sumTotal = ee.Number(weightedSum.reduce(ee.Reducer.sum()));

// Helper function to calculate Otsu's threshold
var otsuThreshold = function(values, counts, totalPixels, sumTotal) {
  // Iterate over the values to find the optimal threshold
  var result = ee.List(values.iterate(function(value, prev) {
    var prevData = ee.Dictionary(prev);

    // Compute weights for the background and foreground
    var weightBackground = prevData.getNumber('weightBackground').add(ee.Number(counts.get(values.indexOf(value))));
    var weightForeground = ee.Number(totalPixels).subtract(weightBackground);

    // Skip this iteration if there's no foreground
    var mask = weightForeground.gt(0);

    var sumBackground = prevData.getNumber('sumBackground').add(ee.Number(value).multiply(ee.Number(counts.get(values.indexOf(value)))));
    var meanBackground = sumBackground.divide(weightBackground);
    var meanForeground = sumTotal.subtract(sumBackground).divide(weightForeground);

    // Compute between-class variance
    var variance = weightBackground.multiply(weightForeground).multiply(meanBackground.subtract(meanForeground).pow(2));

    // Compare variance to find the maximum
    var newMaxVariance = ee.Number(ee.Algorithms.If(
      variance.gt(prevData.get('maxVariance')),
      variance,
      prevData.get('maxVariance')
    ));

    var newThreshold = ee.Number(ee.Algorithms.If(
      variance.gt(prevData.get('maxVariance')),
      value,
      prevData.get('threshold')
    ));

    return ee.Dictionary({
      'maxVariance': newMaxVariance,
      'threshold': newThreshold,
      'weightBackground': weightBackground,
      'sumBackground': sumBackground
    });
  }, ee.Dictionary({
    'maxVariance': ee.Number(-1),
    'threshold': ee.Number(0),
    'weightBackground': ee.Number(0),
    'sumBackground': ee.Number(0)
  })));

  return ee.Number(ee.Dictionary(result).get('threshold'));
};

// Find the optimal Otsu threshold
var thr = otsuThreshold(values, counts, totalPixels, sumTotal);
print('Otsu Threshold:', thr);
thr = 7;

// 4.2 Apply the threshold to the final classification sum

  // Threshold the combined classification to obtain final classification
  var finalClassification = combinedClassification.where(combinedClassification.lt(thr), 0).where(combinedClassification.gte(thr), 1);
  //print('Final Classification', finalClassification);

  // Stratified sampling to compare classification and ground truth
  var testSamplesFinal = finalClassification.addBands(maskedTestGroundTruth).stratifiedSample({
      numPoints: 2000,
      classBand: 'class',
      region: testRoi,
      scale: 30,
      geometries: true
  });

  // Confusion matrix and accuracy
  var validationSampleFinal = testSamplesFinal.errorMatrix('class', 'classification');
  var accuracyFinal = validationSampleFinal.accuracy();
  //print('Error Matrix Final:', validationSampleFinal);
  //print('Accuracy Final:', accuracyFinal);

// Extract confusion matrix elements
var confusionMatrix = validationSampleFinal.array();
var TP = confusionMatrix.get([1, 1]); // True Positives (Debris correctly identified)
var FP = confusionMatrix.get([0, 1]); // False Positives (Non-debris misclassified as debris)
var FN = confusionMatrix.get([1, 0]); // False Negatives (Debris missed)
var TN = confusionMatrix.get([0, 0]); // True Negatives (Non-debris correctly classified)

// Compute Precision: TP / (TP + FP)
var precision = TP.divide(TP.add(FP));

// Compute Recall (Sensitivity): TP / (TP + FN)
var recall = TP.divide(TP.add(FN));

// Compute F1-Score: 2 * (Precision * Recall) / (Precision + Recall)
var f1Score = precision.multiply(recall).multiply(2).divide(precision.add(recall));


// Add Metrics to Summary

var evaluationMetrics = ee.Feature(null, {
  'Accuracy': accuracyFinal,
  'F1-Score': f1Score,
  'Precision': precision,
  'Recall': recall,
  //'TP':TP,
  //'FP':FP,
  //'FN':FN,
  //'TN':TN
});
print('evaluations metrics', evaluationMetrics);



  accuracyList.push(ee.Feature(null, {
    'Final Accuracy': accuracyFinal
  }));

  var accuracyTable = ee.FeatureCollection(accuracyList);
 // print('Accuracy Table', accuracyTable);

  // Display the final classification
  Map.centerObject(testRoi, 12);
  
  Map.addLayer(combinedClassification, {min:0, max:20, palette: jet}, 'Final Classification sum');
 // Map.addLayer(finalClassification, visClass, 'Final Classification mask');

//==================================================
// 5. Smooth and vectorize final classification mask
//==================================================

// Apply a majority filter to smooth the classified image
var kernel = ee.Kernel.square({radius: 2});
var smoothedClassification = finalClassification.reduceNeighborhood({
  reducer: ee.Reducer.mode(),
  kernel: kernel
});

// Display the classified image
Map.addLayer(smoothedClassification, {min: 0, max: 1, palette: ['white', 'black']}, 'Smoothed Classified Image');

// Select the relevant band
var classificationBand = smoothedClassification.select('classification_mode');

// Threshold the image to create a binary mask where 1's are kept
var mask = classificationBand.eq(1);
mask = mask.updateMask(mask);

// Convert the binary mask to vectors (polygons)
var polygons = mask.reduceToVectors({
  geometryType: 'polygon',
  reducer: ee.Reducer.countEvery(),
  scale: 30,  // Adjust to your image's resolution
  maxPixels: 1e8,
  geometry: testRoi  // Ensure the geometry of the mask is used
});

// Add the vector layer to the map to visualize the polygons
Map.addLayer(polygons, {color: 'red'}, 'Vectorized classification result');
// Print the polygons to the console for inspection
//print('vectorized classification result', polygons);

//==========
// 6. Export
//==========

Export.table.toDrive({
  collection: polygons,
  description:'vectorized_approachII_'+selectedYear+testGlacier,
  folder: 'DCG_approachII_GEE_exports',
  fileFormat: 'SHP'
});
Export.image.toDrive({
  image: finalClassification.toDouble(),
  description: 'finalClassification_approachII_' + testGlacier+selectedYear,
  folder: 'DCG_approachII_GEE_exports',
  scale: 30,
  region: testRoi,
  fileFormat: 'GeoTIFF'
});
Export.image.toDrive({
  image: combinedClassification.toDouble(),
  description: 'combinedClassification_approachII_' + testGlacier+selectedYear,
  folder: 'DCG_approachII_GEE_exports',
  scale: 30,
  region: testRoi,
  fileFormat: 'GeoTIFF'
});
Export.image.toDrive({
  image: testInput.toDouble(),
  description: 'testInput_' + testGlacier+selectedYear,
  folder: 'DCG_approachII_GEE_exports',
  scale: 30,
  region: testRoi,
  fileFormat: 'GeoTIFF'
});

Export.table.toDrive({
  collection: accuracyTable,
  description: 'accuracyTable_differentGlaciers_'+testGlacier+selectedYear, 
  folder: 'DCG_approachII_GEE_exports', 
  fileFormat: 'CSV'});
  
  
} 