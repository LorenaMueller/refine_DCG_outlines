/*
Refining Debris-Covered Glacier Outlines Using Land Surface Temperature Data
MSc Thesis Lorena Müller

Create Input Layers for RF Classification

  In this script, the input layers for the Random Forest classification are created, for Zmutt, Unteraar, Oberaletsch, 
  Mauvoisin, Zinal, Belvedere and Satopanth glacier, for the years 2016, 2018, 2020, 2022 and 2024. 
  
  The layers can be exported to google drive, for DCG classification with an XGBoost model in google colab 
  (Link to script: https://colab.research.google.com/drive/1S1pzMnJIYtDjkNwDKT2b7iYK5muQdqWp?usp=sharing)

  All layers can be visualized by selecting them in the 'Layers' menu. 

  Contents
    1. Variable definitions
    2. Landsat Scene Processing: single or composite
    3. Include DEM for topographic information
    4. Normalize LST for Elevation
    5. Normalized Difference Index LST and NIR
    6. Create layers based on LST NIR Index
    7. Create ground truth for 2003 and 2010
    8. Combine all layers in one image
    9. Export
*/

var mode = 'single'; // choose either 'composite' or 'single'

/*  'single': Single Landsat scenes are used for creating the input layers. The scenes were manually selected 
              based on visual inspection of the scenes, to ensure the glacier to be free of clouds, snow or shadows.
    'composite': A composite image of the summer months of the year of analysis is created, for each glacier
                and year.
    */
// =======================
//  * imports *
// =======================
var swissAlti_zmutt = ee.Image("projects/ee-lorenamuellerthesis/assets/swissalti3d_zmutt_reprojected"),
    roi_unteraar = 
    /* color: #00ffff */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[8.093277358211939, 46.605423677609075],
          [8.093277358211939, 46.52894816125691],
          [8.286568068661158, 46.52894816125691],
          [8.286568068661158, 46.605423677609075]]], null, false),
    swissAlti_oberaletsch = ee.Image("projects/ee-lorenamuellerthesis/assets/alti3d_oberaletsch"),
    swissAlti_unteraar = ee.Image("projects/ee-lorenamuellerthesis/assets/alti3d_unteraar"),
    dem_copernicus = ee.ImageCollection("COPERNICUS/DEM/GLO30"),
    debriscover = ee.FeatureCollection("projects/ee-lorenamuellerthesis/assets/debriscover_2016_reprojected"),
    sgi2010 = ee.FeatureCollection("projects/ee-lorenamuellerthesis/assets/sgi210_reprojected"),
    rgi_europe = ee.FeatureCollection("projects/ee-lorenamuellerthesis/assets/rgi_central_europe"),
    roi_oberaletsch = 
    /* color: #00ff00 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[7.912561745928528, 46.398720480474125],
          [8.012468667315247, 46.398720480474125],
          [8.012468667315247, 46.462610294473386],
          [7.912561745928528, 46.462610294473386],
          [7.912561745928528, 46.398720480474125]]]),
    roi_zmutt = 
    /* color: #98ff00 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[7.599852885957441, 45.97761969922328],
          [7.661650981660566, 45.97761969922328],
          [7.661650981660566, 46.01744963942263],
          [7.599852885957441, 46.01744963942263],
          [7.599852885957441, 45.97761969922328]]], null, false),
    roi_belvedere = 
    /* color: #0b4a8b */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[7.869268251163195, 45.920126700794086],
          [7.939134431583117, 45.920126700794086],
          [7.939134431583117, 45.971572003401974],
          [7.869268251163195, 45.971572003401974],
          [7.869268251163195, 45.920126700794086]]], null, false),
    rgi_satopanth = ee.FeatureCollection("projects/ee-lorenamuellerthesis/assets/rgi_v7_satopanth"),
    roi_satopanth = 
    /* color: #98ff00 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[79.26577706182661, 30.815139018130388],
          [79.26594872320356, 30.72649454438789],
          [79.39520974004927, 30.724133509351514],
          [79.41821236456099, 30.773850588265216],
          [79.42919869268599, 30.819414306230968],
          [79.31435723150435, 30.82162558747115]]]),
    sgi2016 = ee.FeatureCollection("projects/ee-lorenamuellerthesis/assets/GLAMOS/SGI_2016_glaciers"),
    inSAR_zmutt1 = ee.Image("projects/ee-lorenamuellerthesis/assets/InSAR/N46E007_summer_vv_COH06"),
    inSAR_zmutt2 = ee.Image("projects/ee-lorenamuellerthesis/assets/InSAR/N47E007_summer_vv_COH06"),
    inSAR_unteraar = ee.Image("projects/ee-lorenamuellerthesis/assets/InSAR/N47E008_summer_vv_COH06"),
    inSAR_satopanth = ee.Image("projects/ee-lorenamuellerthesis/assets/InSAR/N31E079_summer_vv_COH12"),
    coherence_asc_iw2_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/S1A_IW_SLC_20160813_20160825_Stack_ifg_2_flt_deb_TC_coh_IW2_VV_13Aug2016_25Aug2016"),
    coherence_desc_iw2_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/S1A_IW_SLC__1SDV_20160812_20160824_IW2_ifg_flt_deb_TC_coh_IW2_VV_12Aug2016_24Aug2016"),
    coherence_desc_iw3_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/S1A_IW_SLC__1SDV_20160812_20160824_desc_IW3_Stack_ifg_flt_deb_TC_coh_IW3_VV_12Aug2016_24Aug2016"),
    coherence_sar_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/SAR_IMS_2003"),
    coherence_desc_iw2_2018 = ee.Image("projects/ee-lorenamuellerthesis/assets/S1A_IW_SLC_20180814_20180826_Stack_ifg_flt_deb_TC_coh_IW2_VV"),
    coherence_desc_iw2_2020 = ee.Image("projects/ee-lorenamuellerthesis/assets/S1A_IW_SLC_20200815_20200827_Stack_ifg_flt_deb_TC_coh_IW2_VV_15Aug2020_27Aug2020"),
    coherence_ers_2003 = ee.Image("projects/ee-lorenamuellerthesis/assets/SAR_IMS_2003"),
    coherence_desc_iw2_2022 = ee.Image("projects/ee-lorenamuellerthesis/assets/S1A_IW_SLC__1SDV_20220817_20220829_Stack_ifg_flt_deb_TC_coh_IW2_VV_17Aug2022_29Aug2022"),
    coherence_desc_satopanth_24_2016 = ee.Image("projects/ee-lorenamuellerthesis/assets/S1A_IW_SLC_20160731_20160824_satopanth"),
    roi_rhone = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[8.361113562153898, 46.6342219045685],
          [8.361113562153898, 46.569589568355255],
          [8.425314917134367, 46.569589568355255],
          [8.425314917134367, 46.6342219045685]]], null, false),
    coherence_zmutt_2022 = ee.Image("projects/ee-lorenamuellerthesis/assets/S1A_IW_SLC_20220817_20220829_zmutt_Orb_Stack_ifg_flt_deb_TC_coh_IW3_VV_17Aug2022_29Aug2022"),
    coherence_zmutt_2018 = ee.Image("projects/ee-lorenamuellerthesis/assets/S1A_IW_SLC_20180814_20180826_zmutt_Orb_Stack_ifg_flt_deb_TC_coh_IW3_VH_14Aug2018_26Aug2018"),
    coherence_zmutt_2020 = ee.Image("projects/ee-lorenamuellerthesis/assets/S1A_IW_SLC_1SDV_20200815_20200827_zmutt_Orb_Stack_ifg_flt_deb_TC_coh_IW3_VV_15Aug2020_27Aug2020"),
    coherence_zmutt_2024 = ee.Image("projects/ee-lorenamuellerthesis/assets/S1A_IW_SLC_1SDV_20240818_20240830_zmutt_Orb_Stack_ifg_flt_deb_TC_coh_IW3_VV_18Aug2024_30Aug2024"),
    coherence_desc_iw2_2024 = ee.Image("projects/ee-lorenamuellerthesis/assets/S1A_IW_SLC_1SDV_20240818_20240830_unt_ober_bel_Orb_Stack_ifg_flt_deb_TC_coh_IW2_VV"),
    coherence_satopanth_2024 = ee.Image("projects/ee-lorenamuellerthesis/assets/S1A_IW_SLC_1SDV_20240818_20240830_satopanth_Orb_Stack_ifg_flt_deb_TC_coh_IW2_VV_18Aug2024_30Aug2024"),
    roi_zinal = 
    /* color: #0b4a8b */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[7.601100645576628, 46.09574338992338],
          [7.601100645576628, 46.0420304406043],
          [7.671138487373503, 46.0420304406043],
          [7.671138487373503, 46.09574338992338]]], null, false),
    roi_mauvoisin = 
    /* color: #bf04c2 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[7.304237207931346, 45.96183734280675],
          [7.304237207931346, 45.90871083134632],
          [7.371528467696971, 45.90871083134632],
          [7.371528467696971, 45.96183734280675]]], null, false),
    poi_satopanth = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry.Point([79.36251814474248, 30.79221709198193]),
    poi_zmutt = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry.Point([7.639709936807106, 45.99740167100306]),
    poi_oberaletsch = 
    /* color: #98ff00 */
    /* shown: false */
    ee.Geometry.Point([7.970069805422377, 46.421437131324005]),
    poi_unteraar = 
    /* color: #0b4a8b */
    /* shown: false */
    ee.Geometry.Point([8.197049496487372, 46.57119193290076]),
    poi_belvedere = 
    /* color: #ffc82d */
    /* shown: false */
    ee.Geometry.Point([7.931522162280613, 45.952149547271596]),
    poi_mauvoisin = 
    /* color: #00ffff */
    /* shown: false */
    ee.Geometry.Point([7.33213245938833, 45.943000570277015]),
    poi_zinal = 
    /* color: #bf04c2 */
    /* shown: false */
    ee.Geometry.Point([7.6327634341695605, 46.07755263661006]),
    coherence_desc_satopanth_12_2018 = ee.Image("projects/ee-lorenamuellerthesis/assets/S1A_IW_SLC_20180814_20180826_satopanth_Orb_Stack_ifg_flt_deb_TC_coh_IW2_VV_14Aug2018_26Aug2018"),
    coherence_desc_satopanth_12_2020 = ee.Image("projects/ee-lorenamuellerthesis/assets/S1A_IW_SLC_20200815_20200827_satopanth_Orb_Stack_ifg_flt_deb_TC_coh_IW2_VV_15Aug2020_27Aug2020"),
    coherence_desc_satopanth_12_2022 = ee.Image("projects/ee-lorenamuellerthesis/assets/S1A_IW_SLC_20220817_20220817_satopanth_Orb_Stack_ifg_flt_deb_TC_coh_IW2_VV_17Aug2022_29Aug2022");
                    
//========================
// 1. Variable definitions
//========================
//Map.centerObject(roi_zmutt, 12);
//Map.addLayer(coherence_desc_iw3_2016, {}, 'coherence zmutt');

// Glacier-specific variables
var glaciers = {
  zmutt: {
    name: 'zmutt',
    roi: roi_zmutt,
    poi: poi_zmutt,
    swissAlti: swissAlti_zmutt,
    sgiId: 'B57-05',
    rgiId1: 753583,
    rgiId2: 753583,
    crs: 'EPSG:32632',
    rgi: rgi_europe,
    landsat: {
      2003: ee.Image('LANDSAT/LT05/C02/T1_L2/LT05_195028_20030813'),
      //2010: ee.Image('LANDSAT/LT05/C02/T1_L2/LT05_195028_20100901'),
      2010: ee.Image('LANDSAT/LT05/C02/T1_L2/LT05_195028_20100731'),
      2016: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_195028_20160901'),
      2018: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_195028_20180806'), // not ideal but best one
      2020: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_195028_20200827'),
      2022: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_195028_20220801'),
      2024: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_195028_20240806')
    },
    inSAR: ee.ImageCollection([inSAR_zmutt1, inSAR_zmutt2]).mosaic(),
    coherence: {
      2016: coherence_desc_iw3_2016, // zmutt: asc IW2 or desc IW3
      2018: coherence_zmutt_2018,
      2020: coherence_zmutt_2018,
      2022: coherence_zmutt_2022,
      2024: coherence_zmutt_2024
    }
  },
  zinal: {
    name: 'zinal',
    roi: roi_zinal,
    poi: poi_zinal,
    crs: 'EPSG:32632',
    rgi: rgi_europe,
    landsat: {
      2016: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_195028_20160901'),
      2018: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_195028_20180806'),
      2020: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_195028_20200912'),
      2022: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_195028_20220716'),
      2024: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_195028_20240806')

    },
    inSAR: ee.ImageCollection([inSAR_zmutt1, inSAR_zmutt2]).mosaic(),
    coherence: {
      2016: coherence_desc_iw3_2016, 
      2018: coherence_zmutt_2018,
      2020: coherence_zmutt_2018,
      2022: coherence_zmutt_2022,
      2024: coherence_zmutt_2024
    }
  },
  mauvoisin: {
    name: 'mauvoisin',
    roi: roi_mauvoisin,
    poi: poi_mauvoisin,
    crs: 'EPSG:32632',
    rgi: rgi_europe,
    landsat: {
      2016 : ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_195028_20160901'),
      2018 : ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_195028_20180806'),
      2020 : ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_195028_20200827'),
      2022 : ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_195028_20220716'),
      2024 : ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_195028_20240822')
    },
    inSAR: ee.ImageCollection([inSAR_zmutt1, inSAR_zmutt2]).mosaic(),
    coherence: {
      2016: coherence_desc_iw3_2016, 
      2018: coherence_zmutt_2018,
      2020: coherence_zmutt_2018,
      2022: coherence_zmutt_2022,
      2024: coherence_zmutt_2024
    }
  },

  unteraar: {
    name: 'unteraar',
    roi: roi_unteraar,
    poi: poi_unteraar,
    swissAlti: swissAlti_unteraar,
    sgiId: 'A54g-11',
    rgiId1: 754189,
    rgiId2: 754182,
    crs: 'EPSG:32632',
    rgi: rgi_europe,
    landsat: {
      2003: ee.Image('LANDSAT/LT05/C02/T1_L2/LT05_195028_20030813'),
      2010: ee.Image('LANDSAT/LT05/C02/T1_L2/LT05_194028_20100825'),
      2016: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_194028_20160825'),
      2018: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_194028_20180815'),
      2020: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_194028_20200719'),
      2022: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_195028_20220716'),
      2024: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_194028_20240831')
    },

    inSAR: inSAR_unteraar,
    coherence: {
    2003: coherence_ers_2003,
    2016: coherence_desc_iw2_2016,
    2018: coherence_desc_iw2_2018,
    2020: coherence_desc_iw2_2020,
    2022: coherence_desc_iw2_2022,
    2024: coherence_desc_iw2_2024
    }
  },
  oberaletsch: {
    name: 'oberaletsch',
    roi: roi_oberaletsch,
    poi: poi_oberaletsch,
    swissAlti: swissAlti_oberaletsch,
    sgiId: 'B36-01',
    rgiId1: 753951, 
    rgiId2:753959,
    crs: 'EPSG:32632',
    rgi: rgi_europe,
    landsat: {
      2003: ee.Image('LANDSAT/LT05/C02/T1_L2/LT05_195028_20030813'),
      2010: ee.Image('LANDSAT/LT05/C02/T1_L2/LT05_194028_20100825'),
      2016: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_194028_20160825'),
      2018: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_194028_20180815'),
      2020: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_194028_20200719'),
      2022: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_195028_20220716'),
      2024: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_194028_20240831')
    },

    inSAR: ee.ImageCollection([inSAR_unteraar, inSAR_zmutt2]).mosaic(),
    coherence: {
    2003: coherence_ers_2003,
    2016: coherence_desc_iw2_2016,
    2018: coherence_desc_iw2_2018,
    2020: coherence_desc_iw2_2020,
    2022: coherence_desc_iw2_2022,
    2024: coherence_desc_iw2_2024
    }
  },
  satopanth: {
    name: 'satopanth',
    roi: roi_satopanth,
    poi: poi_satopanth,
    rgi: rgi_satopanth,
    crs: 'EPSG:32644',
    landsat:{
      2003: ee.Image('LANDSAT/LT05/C02/T1_L2/LT05_146039_19981011'), //1998
      2016: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_145039_20160919'),
      2018: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_145039_20180707'),
      2020: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_145039_20200930'),
      2022: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_145039_20220718'),
      2024: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_145039_20240723')
    },
    inSAR: inSAR_satopanth,
    coherence: {
      2016: coherence_desc_satopanth_24_2016,
      2018: coherence_desc_satopanth_12_2018,
      2020: coherence_desc_satopanth_12_2020,
      2022: coherence_desc_satopanth_12_2022,
      2024: coherence_satopanth_2024 // 12 days, also desc
    }
  },
  belvedere: {
    name: 'belvedere',
    roi: roi_belvedere,
    poi: poi_belvedere,
    rgi: rgi_europe,
    crs: 'EPSG:4326',
    landsat:{
      2003: ee.Image('LANDSAT/LT05/C02/T1_L2/LT05_195028_20030813'),
      2016: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_194028_20160825'),
      2018: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_194028_20180815'),
      2020: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_194028_20200719'),
      2022: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_195028_20220716'),
      2024: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_194028_20240831')
    },

    inSAR: inSAR_zmutt1,
    coherence: {
    2003: coherence_ers_2003,
    2016: coherence_desc_iw2_2016,
    2018: coherence_desc_iw2_2018,
    2020: coherence_desc_iw2_2020,
    2022: coherence_desc_iw2_2022,
    2024: coherence_desc_iw2_2024
    }
  },
    rhone: {
    name: 'rhone',
    roi: roi_rhone,
    rgi: rgi_europe,
    crs: 'EPSG:4326',
    landsat: {
      2003: ee.Image('LANDSAT/LT05/C02/T1_L2/LT05_195028_20030813'),
      2010: ee.Image('LANDSAT/LT05/C02/T1_L2/LT05_194028_20100825'),
      2016: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_194028_20160825'),
      2018: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_194028_20180815'),
      2020: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_194028_20200719'),
      2022: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_195028_20220716'),
      2024: ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_194028_20240831')
    },
    inSAR: inSAR_satopanth,
    coherence: {
    2003: coherence_ers_2003,
    2016: coherence_desc_iw2_2016,
    2018: coherence_desc_iw2_2018,
    2020: coherence_desc_iw2_2020,
    2022: coherence_desc_iw2_2022,
   // 2024: coherence_desc_iw2_2024
    }
  },
};

// Palettes
var palettes = require('users/gena/packages:palettes');
var jet = palettes.misc.jet[7];
var blueToRed = palettes.colorbrewer.RdYlBu[11];
var trueColour = {bands: ['red', 'green', 'blue'], min: 0.04, max: 0.545};
var visGlamos = {palette: ['gray', 'cyan', 'blue'], min: 0.0, max: 10.0, opacity: 0.8};

// Definitions of bands
var L5_bands = ee.List([ 'SR_B1', 'SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B7', 'ST_B6']);
var L5_band_names = ee.List(['blue', 'green', 'red', 'nir', 'swir1', 'swir2', 'lst']);
var L8_bands = ee.List([ 'SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B6', 'SR_B7', 'ST_B10']);
var L8_band_names = ee.List([ 'blue', 'green', 'red', 'nir', 'swir1', 'swir2', 'lst']);


// Define a function to generate layers for a given glacier and year
function generateLayersForGlacierYear(glacier, year) {
  var selectedGlacier = glaciers[glacier];
  var glacierName = selectedGlacier.name;
  var roi = selectedGlacier.roi;
  var poi = selectedGlacier.poi;
  var swissAlti = selectedGlacier.swissAlti;
  var crs = selectedGlacier.crs;
  var rgi = selectedGlacier.rgi;
  var inSAR = selectedGlacier.inSAR;
  var coherences = selectedGlacier.coherence;
  var sentinelScenes = selectedGlacier.sentinel;

// Define years of interest
var years = [2016, 2018, 2020, 2022, 2024];

// Initialize empty dictionary
var sentinel = {};

// Loop through each year
years.forEach(function(year) {
  var start = ee.Date.fromYMD(year, 8, 1);
  var end = ee.Date.fromYMD(year, 8, 31);
  
  // Get only images with both VV and VH polarizations
  var collection = ee.ImageCollection('COPERNICUS/S1_GRD')
    .filterBounds(poi)
    .filterDate(start, end)
    .filter(ee.Filter.eq('instrumentMode', 'IW'))
    .filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'))
    .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))
    .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'));

  // Combine images using .mean() to ensure band consistency
  var image = collection.mean().select(['VV', 'VH']);

  // Save to dictionary
  sentinel[year] = image;
  
  // Debugging info
  print('Sentinel-1 image for ' + year, image);
  print('Bands for ' + year, image.bandNames());
});

print('I try once more', sentinel[year]);

//============================
// 2. Landsat scene processing
//============================

  // 2.1 single scenes
  
  if(mode === 'single'){
  var landsatImage = selectedGlacier.landsat[year];
    
      // Function to apply scale factors for Landsat 5
   var scaledL5 = function applyScaleFactorsL5(image) {
      var opticalBands = image.select('SR_B.').multiply(0.0000275).add(-0.2);
      var thermalBand = image.select('ST_B6').multiply(0.00341802).add(149.0);
      return image.addBands(opticalBands, null, true).addBands(thermalBand, null, true);
    };
    // Function to apply scale factors for Landsat 8
    var scaledL8 = function applyScaleFactorsL8(image) {
      var opticalBands = image.select('SR_B.').multiply(0.0000275).add(-0.2);
      var thermalBand = image.select('ST_B10').multiply(0.00341802).add(149.0);
      return image.addBands(opticalBands, null, true).addBands(thermalBand, null, true);
    };
      // Process Landsat images
      if (year <= 2010) {
        landsatImage = scaledL5(landsatImage).select(L5_bands, L5_band_names);
      } else if (year >= 2016) {
        landsatImage = scaledL8(landsatImage).select(L8_bands, L8_band_names);
      }
  }
  // 2.2 composite
  else if (mode === 'composite'){
     if(glacierName === 'satopanth'){
      //var startDate = 1997 + '-01-01';
      //var endDate = 1999 + '-01-01'; 
       var startDate = year + '-01-01';
       var endDate = (year + 1) + '-01-01';
     }
     else{
       var startDate = year + '-01-01';
       var endDate = (year + 1) + '-01-01';
    }
    
    // Determine the Landsat collection and scaling factors based on the year
    var collectionName, LC_BANDS, STD_NAMES, applyScaleFactors;
    if (year >= 2013) {
      // Landsat 8
      collectionName = 'LANDSAT/LC08/C02/T1_L2';
      LC_BANDS = ['SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B6', 'SR_B7', 'ST_B10'];
      STD_NAMES = ['blue', 'green', 'red', 'nir', 'swir1', 'swir2', 'lst'];
      applyScaleFactors = function(image) {
        var opticalBands = image.select(['SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B6', 'SR_B7']).multiply(0.0000275).add(-0.2);
        var thermalBand = image.select('ST_B10').multiply(0.00341802).add(149.0).rename('lst');
        return image.addBands(opticalBands, null, true)
                    .addBands(thermalBand, null, true)
                    .select(LC_BANDS, STD_NAMES);
      };
    } else {
      // Landsat 5
      collectionName = 'LANDSAT/LT05/C02/T1_L2';
      LC_BANDS = ['SR_B1', 'SR_B2', 'SR_B3', 'SR_B4', 'SR_B5','SR_B7' ,'ST_B6'];
      STD_NAMES = ['blue', 'green', 'red', 'nir', 'swir1', 'swir2', 'lst'];
      
      applyScaleFactors = function(image) {
        var opticalBands = image.select(['SR_B1', 'SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B7']).multiply(0.0000275).add(-0.2);
        var thermalBand = image.select('ST_B6').multiply(0.00341802).add(149.0).rename('lst');
        return image.addBands(opticalBands, null, true)
                    .addBands(thermalBand, null, true)
                    .select(LC_BANDS, STD_NAMES);
      };
    }
    
    // Filter the Landsat collection
    var collection = ee.ImageCollection(collectionName)
      .filterBounds(roi)
      .filter(ee.Filter.calendarRange(6, 10, 'month')) // Filtering summer months
      .filterDate(startDate, endDate)
      .map(applyScaleFactors);

    
    // Simple cloud score
    var cloudScore = function(img) {
      // A helper to apply an expression and linearly rescale the output.
      var rescale = function(img, exp, thresholds) {
        return img.expression(exp, {img: img})
            .subtract(thresholds[0]).divide(thresholds[1] - thresholds[0]);
      };
    
      // Compute several indicators of cloudiness and take the minimum of them.
      var score = ee.Image(1.0);
      
      // Clouds are reasonably bright in the blue band.
      score = score.min(rescale(img, 'img.blue', [0.3, 0.5]));
    
      // Clouds are reasonably bright in all visible bands.
      score = score.min(rescale(img, 'img.red + img.green + img.blue', [0.5, 1.6]));
    
      // Clouds are reasonably bright in all infrared bands.
      score = score.min(rescale(img, 'img.nir + img.swir1 + img.swir2', [1.3, 1.8]));
    
      // Clouds are reasonably cool in temperature.
      score = score.min(rescale(img, 'img.lst', [300, 290]));
    
      // However, clouds are not snow.
      var ndsi = img.normalizedDifference(['green', 'swir1']);
      score = score.min(rescale(ndsi, 'img', [0.8, 0.6]));
      
      return score.clamp(0, 1).rename(['cloudscore']);
    };
    
    // Apply the cloud score and mask function
    collection= collection.map(function(img) {
      // Compute cloud score and mask cloudy pixels
      var score = cloudScore(img);
      return img.updateMask(score.lt(0.2)).addBands(score);
    });
    
    // Calculate the 90th percentile of the LST band
    var highLST = collection.select('lst').reduce(ee.Reducer.percentile([90]));
    
    // Create a mask for high LST values in each image
    var gethighLST = function(image) {
      var highLSTMask = image.select('lst').gte(highLST);
      return highLSTMask.rename('highLSTMask');
    };
    
    // Apply the mask to the collection
    var highLSTmasks = collection.map(gethighLST);
    
    var applyMask = function(image) {
      var mask = highLSTmasks.filterMetadata('system:index', 'equals', image.get('system:index')).first().select('highLSTMask');
      return image.updateMask(mask);
    };
    
    var maskedCollection = collection.map(applyMask);
    
    // Combine the masked images using the median
    var landsatImage = maskedCollection.median();
     }
    
   

  // Center map
  Map.centerObject(roi, 12);

//==========================================


//==========================================
//===========================================
// 3. Include DEM for topographic information
//===========================================

  // DEM inclusion
  var dem;
  if (year === 2003) {
    dem = ee.Image(dem_nasa).setDefaultProjection({ crs: crs, scale: 30 });
  } else if (year > 2004) {
    dem = ee.ImageCollection("COPERNICUS/DEM/GLO30").filterBounds(roi).select('DEM').mosaic()
      .setDefaultProjection({ crs: crs, scale: 30 });
      dem = dem.select('DEM').rename('elevation');
/*  } else if (year === 2016) {
    dem = ee.Image(swissAlti).select('b1').rename('elevation')
      .setDefaultProjection({ crs: crs, scale: 30 });
  }
*/

  // Create derived layers (similar logic as in your original script)
  var slope = ee.Terrain.slope(dem);
  var aspect = ee.Terrain.aspect(dem);
  var elevation = dem.select('elevation');

  // Normalize LST, calculate indices, etc.

var xyGrad = elevation.gradient();
var gradient = xyGrad.select('x').pow(2).add(xyGrad.select('y').pow(2)).sqrt();
gradient = gradient.rename('gradient');

var TPI = elevation.select('elevation').subtract(elevation.select('elevation').convolve(ee.Kernel.circle(100,"pixels")));
TPI = TPI.rename('TPI');

// ==============================
// 4. Normalize LST for Elevation
// ==============================

// Select elevation and lst
var lst = landsatImage.select('lst');
var img = elevation.addBands(lst);
Map.addLayer(lst, {palette: jet}, 'original lst'+glacier+year, false);
//Map.addLayer(lst, {min: 0, max: 300, palette: jet}, 'LST ' + year, false);

// Perform linear regression
var linearFit = img.select(['elevation', 'lst']).reduceRegion({
  reducer: ee.Reducer.linearFit(),
  geometry: roi,
  scale: 30,
  maxPixels: 1e9
});

// Extract the slope and intercept from the regression
var regressionSlope = ee.Number(linearFit.get('scale'));
var intercept = ee.Number(linearFit.get('offset'));


// Calculate predicted LST and compute residuals
var predictedLst = (elevation.multiply(regressionSlope)).add(intercept);

var normalizedLst1 = lst.subtract(predictedLst).rename('normalizedLst');
// partial debugging: LST normalized by regression produces holes in lstNir layer -> rescale to [0, 1]

// Define function to normalize and rescale layer
function rescale(image, bandName){
  // Default values for scale and maxPixels
  roi = roi;
  var scale =  30;
  var maxPixels =  1e9;
  image = image;

  // Select the band by name to ensure consistency
  var band = image.select(bandName);

  // Compute mean and standard deviation of the selected band
  var stats = band.reduceRegion({
    reducer: ee.Reducer.mean().combine({
      reducer2: ee.Reducer.stdDev(),
      sharedInputs: true
    }),
    geometry: roi,
    scale: scale,
    maxPixels: maxPixels
  });

  // Extract mean and standard deviation
  var mean = ee.Number(stats.get(bandName + '_mean'));
  var stdDev = ee.Number(stats.get(bandName + '_stdDev'));

  // Set the threshold to 3 standard deviations
  var lowerBound = mean.subtract(stdDev.multiply(3));
  var upperBound = mean.add(stdDev.multiply(3));

  // Mask values outside the desired range
  var filteredImage = band.updateMask(
    band.gte(lowerBound).and(band.lte(upperBound))
  );

  // Compute the min and max of the filtered image
  var minMax = filteredImage.reduceRegion({
    reducer: ee.Reducer.minMax(),
    geometry: roi,
    scale: scale,
    maxPixels: maxPixels
  });

  var min = ee.Number(minMax.get(bandName + '_min'));
  var max = ee.Number(minMax.get(bandName + '_max'));

  // Rescale the image to the range [0, 1]
  var rescaledImage = band.subtract(min).divide(max.subtract(min));

  // Ensure no values are smaller than 0
  var normalizedImage = rescaledImage.max(0);

  // Return the normalized and rescaled image
  return normalizedImage;
}

// apply to normalized lst
var normalizedLst = rescale(normalizedLst1, 'normalizedLst');

//===========================================
// 5. Normalized Difference Index LST and NIR
//===========================================

// add relevant bands to one image and scale them

// Function to scale image bands between 0 and 1
function scaleImageBands(image) {
  // Get min and max for each band
  var stats = image.reduceRegion({
    reducer: ee.Reducer.minMax(),
    geometry: roi,
    scale: 30,
    bestEffort: true
  });
  
  // Scale each band
  var bands = image.bandNames();
  var scaledBands = bands.map(function(band) {
    var bandMin = ee.Number(stats.get(ee.String(band).cat('_min')));
    var bandMax = ee.Number(stats.get(ee.String(band).cat('_max')));
    
    // Handle case where min and max values are the same
    var scaledBand = ee.Algorithms.If(
      bandMin.neq(bandMax),
      image.select([band]).unitScale(bandMin, bandMax).rename([band]),
      image.select([band]).subtract(bandMin).divide(bandMax.subtract(bandMin)).rename([band])
    );
    
    return scaledBand;
  });
  
  // Concatenate the scaled bands into a single image
  return ee.ImageCollection(scaledBands).toBands().rename(bands);
}

var combinedImage = landsatImage.addBands(elevation).addBands(normalizedLst);
print('combinedImage', combinedImage);

// Define the function to calculate and add layers

function addNormalizedDifferenceLayers(image, year, glacier) {
  //var lstElevRegression = 'normalizedLst';

  var lstNir = image.normalizedDifference(['normalizedLst', 'nir']).rename('lstNir');
 
 // Calculate Normalized Difference Indices used for the Classification:
  var ndwi = image.normalizedDifference(['green', 'nir']).rename('ndwi');
  var ndsi = image.normalizedDifference(['green', 'swir1']).rename('ndsi');
  var ndvi = image.normalizedDifference(['nir', 'red']).rename('ndvi');
  var ndri = image.normalizedDifference(['swir1', 'red']).rename('ndri');


  //Map.addLayer(lstNir, {min: -1, max: 1, palette: blueToRed}, 'lstNir ' + glacier + year, false);

  // Return the images for further use
  return lstNir.addBands(ndwi).addBands(ndsi).addBands(ndvi).addBands(ndri);
}

// No scaling:
// var combinedImage_scaled = scaleImageBands(combinedImage);

// lstNir layers
var lstNir_layers = addNormalizedDifferenceLayers(combinedImage, year, glacier);

// Extract layers and assign variables
var lstNir = lstNir_layers.select('lstNir');
var ndri = lstNir_layers.select('ndri');
var ndvi = lstNir_layers.select('ndvi');
var ndsi = lstNir_layers.select('ndsi');
var ndwi = lstNir_layers.select('ndwi');

//========================================
// 6. Create layers based on LST NIR Index
//========================================

// Edge detection filters: sobel

var debris = debriscover;
//print('A Sobel kernel', ee.Kernel.sobel());
var sobel = ee.Kernel.sobel();
var edges = lstNir.convolve(sobel);
edges = edges.select('lstNir').rename('edges');

// Low pass filter for smoothing
var boxcar = ee.Kernel.square({radius: 5, units: 'pixels', normalize: true});
var smoothLstNir = lstNir.convolve(boxcar);
smoothLstNir = smoothLstNir.select('lstNir').rename('smooth');

// Super pixel means (SNIC)
var snic = ee.Algorithms.Image.Segmentation.SNIC({
  image: lstNir,
  size: 5,          // Control segment size
  compactness: 1,
  connectivity: 4
});

// Lock map zoom to maintain the desired scale of the segmentation computation.
// Map.setLocked(false, 13, 13);

// Generate superpixel means
var clusters = snic.select('clusters');
var superpixelMeans = lstNir.addBands(clusters).reduceConnectedComponents({
  reducer: ee.Reducer.mean(),
  labelBand: 'clusters'
});
//print('superPixelMeans', superpixelMeans);
superpixelMeans = superpixelMeans.select('lstNir').rename('lstNir_superPixelMeans');


//=========================================
// 7. Create ground truth for 2003 and 2010
//=========================================

// 7.1 Create NDSI mask

var ndsiThreshold = 0.4;
var ndsiMask = ndsi.gt(ndsiThreshold);
var binaryNdsiMask = ndsiMask.updateMask(ndsiMask).unmask(0);
//Map.addLayer(binaryNdsiMask, {min: 0, max: 1, palette: ['black', 'white']}, 'NDSI Binary Mask', false);


// 7.2 Rasterize glacier inventory

// RGI 7.0 (2003)
var rgi_fc = ee.FeatureCollection(rgi);//.filter(ee.Filter.or(ee.Filter.eq('anlys_id', rgiId1),ee.Filter.eq('anlys_id', rgiId2)));
var rasterizedRgi = ee.Image(0).where(rgi_fc.reduceToImage(['area_km2'], ee.Reducer.first()), 1);
//rasterizedRgi = rasterizedRgi.reproject({crs: crs,scale: 30 });
//Map.addLayer(rasterizedRgi, {min: 0, max: 1, palette: ['black', 'white']}, 'RGI 7.0', false);

// SGI 2010
var sgi2010_fc = ee.FeatureCollection(sgi2010);//.filter(ee.Filter.eq('sgi-id', sgiId));
var rasterizedSgi = ee.Image(0).where(sgi2010_fc.reduceToImage(['Shape_Area'], ee.Reducer.first()), 1);
//rasterizedSgi = rasterizedSgi.reproject({crs: crs,scale: 30 });
//print('rasterized SGI 2010', rasterizedSgi); 
//Map.addLayer(rasterizedSgi, {min: 0, max: 1, palette: ['black', 'white']}, 'SGI 2010', false);

// 7.3 Create ground truth

// RGI
var groundTruth_2003 = rasterizedRgi.subtract(binaryNdsiMask);
groundTruth_2003 = groundTruth_2003.eq(1).rename('class');
//Map.addLayer(groundTruth_2003, {min: 0, max: 1, palette: ['black', 'white']}, 'ground truth 2003', false);

// SGI 2010
var groundTruth_2010 = rasterizedSgi.subtract(binaryNdsiMask);
groundTruth_2010 = groundTruth_2010.eq(1).rename('class');
//Map.addLayer(groundTruth_2010, {min: 0, max: 1, palette: ['black', 'white']}, 'ground truth 2010', false);

// For 2016 take SGI2016 debriscover:
var rasterizedDCG2016 = ee.Image(0).where(debriscover.reduceToImage(['area_km2'], ee.Reducer.first()), 1);
var groundTruth_2016 = rasterizedDCG2016.eq(1).rename('class');

var groundTruths = {
  2003: groundTruth_2003,
  2010: groundTruth_2010,
  2016: groundTruth_2016,
  2018: groundTruth_2016,
  2020: groundTruth_2016
};
var groundTruth = groundTruths[year];

// Glacier Inventory Layer
var sgi2016_fc = ee.FeatureCollection(sgi2016);//.filter(ee.Filter.eq('sgi-id', sgiId));
var rasterizedSgi2016 = ee.Image(0).where(sgi2016_fc.reduceToImage(['area_km2'], ee.Reducer.first()), 1);
var glacierInventories = {
  2003: rasterizedRgi,
  2010: rasterizedSgi,
  2016: rasterizedSgi2016,
  2018: rasterizedSgi2016,
  2020: rasterizedSgi2016,
  2022: rasterizedSgi2016,
  2024: rasterizedSgi2016
};
var glacierInventory = glacierInventories[year];

//===================================
// 8. Combine all layers in one image
//===================================

// scale bands for comparability between different years
lstNir = rescale(lstNir, 'lstNir');
ndri = rescale(ndri, 'ndri');
superpixelMeans = rescale(superpixelMeans, 'lstNir_superPixelMeans');
edges = rescale(edges, 'edges');
smoothLstNir = rescale(smoothLstNir, 'smooth');
ndwi = rescale(ndwi, 'ndwi');
ndsi = rescale(ndsi, 'ndsi');
ndvi = rescale(ndvi, 'ndvi');
slope = rescale(slope, 'slope');
aspect = rescale(aspect, 'aspect');
elevation = rescale(elevation, 'elevation');
gradient = rescale(gradient, 'gradient');
TPI = rescale(TPI, 'TPI');
glacierInventory = glacierInventory.rename('glacierInventory');

inSAR = inSAR.rename('inSAR');
inSAR = rescale(inSAR, 'inSAR');

normalizedLst = normalizedLst.rename('normalizedLst');

var coherence = coherences[year];
coherence = rescale(coherence, 'b1').rename('coherence');

// Sentinel-1 image for the selected year
var selectedImage = sentinel[year];
var sentinel1 = rescale(selectedImage, 'VH');

print('✅ Processed Sentinel-1 image for ' + glacier, sentinel1);


  // Combine and export the final image
  var image = lstNir
    .addBands(ndri)
    .addBands(superpixelMeans)
    .addBands(edges)
    .addBands(smoothLstNir)
    .addBands(ndwi)
    .addBands(ndsi)
    .addBands(ndvi)
    .addBands(slope)
    .addBands(aspect)
    .addBands(elevation)
    .addBands(gradient)
    .addBands(TPI)
    .addBands(glacierInventory)
    .addBands(inSAR)
    .addBands(normalizedLst)
    .addBands(coherence)
    .addBands(sentinel1);
    print('image', image);
    
    //==================
    
// Dictionary to store buffers
var buffers = {};

// Function to process a given ROI
function processGlacierBuffer(roi, name) {
  // Load Copernicus DEM
  var dem = ee.ImageCollection("COPERNICUS/DEM/GLO30")
    .filterBounds(roi)
    .select('DEM')
    .mosaic()
    .setDefaultProjection({crs: 'EPSG:4326', scale: 30})
    .rename('elevation');

  // Load RGI Glacier Outlines
if (name === 'satopanth'){
  rgi = ee.FeatureCollection(rgi_satopanth).filterBounds(roi);
}else{
  var rgi = ee.FeatureCollection(rgi_europe).filterBounds(roi);
}
//print('rgi', rgi.limit(10))

  // Clip DEM to glacier areas
  var demClipped = dem.clip(roi).clip(rgi);

  // Normalize DEM within the RGI
  var minElev = demClipped.reduceRegion({
    reducer: ee.Reducer.min(),
    geometry: rgi,
    scale: 30,
    bestEffort: true
  }).getNumber('elevation');

  var maxElev = demClipped.reduceRegion({
    reducer: ee.Reducer.max(),
    geometry: rgi,
    scale: 30,
    bestEffort: true
  }).getNumber('elevation');

  // Ensure no division by zero
  var range = maxElev.subtract(minElev);
  var normDEM = ee.Algorithms.If(
    range.gt(0),
    demClipped.subtract(minElev).divide(range).rename("normalized_elevation"),
    ee.Image(0)
  );

  // Convert to integer (for vectorization)
  normDEM = ee.Image(normDEM).multiply(100).toInt();

  // Mask only areas where elevation is valid
  var lowElevMask = normDEM.lte(10).selfMask();

  // Convert raster to vector (only inside RGI)
  var lowElevVector = lowElevMask.reduceToVectors({
    geometryType: 'polygon',
    reducer: ee.Reducer.countEvery(),
    scale: 30,
    bestEffort: true,
    geometry: rgi
  });

  // **Buffer Creation**
  var lowElevBuffer = lowElevVector.map(function(f) {
    return f.buffer(300);
  });

  var glacierBuffer = rgi.map(function(f) {
    return f.buffer(100);
  });

  // **Merge and dissolve buffers**
  var finalBuffer = glacierBuffer.merge(lowElevBuffer).union();

  // **Store buffer in dictionary**
  buffers[name] = finalBuffer;

  // **Display Results**
  //Map.addLayer(normDEM, {min: 0, max: 100, palette: ['blue', 'white', 'red']}, "Normalized DEM - " + name, false);
  //Map.addLayer(finalBuffer, {color: 'red'}, 'Final Buffer - ' + name, false);
}

// **Define ROIs and names**
var roiDict = {
  'zmutt': glaciers['zmutt'].roi,
  'unteraar':glaciers['unteraar'].roi,
  'oberaletsch': glaciers['oberaletsch'].roi,
  'belvedere': glaciers['belvedere'].roi,
  'satopanth': glaciers['satopanth'].roi,
  'zinal': glaciers['zinal'].roi,
  'mauvoisin': glaciers['mauvoisin'].roi
};

// **Run function for each ROI**
Object.keys(roiDict).forEach(function(name) {
  processGlacierBuffer(roiDict[name], name);
});

// **Print Buffers Dictionary**
//print('Buffers:', buffers);
    

//=======
// Export
//=======
  
  // export to drive for download
  
  Export.image.toDrive({
    image: image.toDouble(),
    description: glacier + '_'+ year + '_layers_drive',
    folder: 'GEE_Exports_input_layers_DCG',
    region: roi,
    scale: 30,
    crs: crs,
    maxPixels: 1e9
  });
  /*
  Export.table.toDrive({
    collection: rgi, 
    description: 'rgi7_'+glacier, 
    folder: 'GEE_Exports_input_layers_DCG',
    fileFormat: 'SHP'
   });
*/
/*
  Export.image.toDrive({
    image: groundTruth_2016.toDouble(),
    description: 'groundTruth_'+glacier + '_2016',
    folder: 'GEE_Exports_input_layers_DCG',
    region: roi,
    scale: 30,
    crs: crs,
    maxPixels: 1e9
  });
  
  */
  /*
   Export.image.toDrive({
    image: groundTruth_2003.toDouble(),
    description: 'groundTruth_'+glacier + '_2003',
    folder: 'GEE_Exports_input_layers_DCG',
    region: roi,
    scale: 30,
    crs: crs,
    maxPixels: 1e9
  });
  
  var buffer = buffers[glacier].select('Feature union_result');
  
  Export.table.toDrive({
    collection: buffer, 
    description: 'rgi_buffer_'+glacier, 
    folder: 'GEE_Exports_input_layers_DCG',
    fileFormat: 'SHP'
   });
  */
  /*
  //export to assets for further use in GEE
  Export.image.toAsset({
    image: image,
    description: glacier + '_'+ year + '_layers_assets',
    region: roi,
    // update assetId
    assetId: 'projects/ee-lorenamuellerthesis/assets/RF_inputs/fromScript/rf_inputs_automatedScript_inSAR/'+glacier + '_'+ year + '_layers_assets',
    scale:30,
    crs: crs
  });

*/

// Define visualization parameters for each band
var bandVisParams = {
  'lstNir': {min: 0, max: 1, palette: blueToRed},
  'ndri': {min: 0, max: 1, palette: ['green', 'white', 'brown']},
  'lstNir_superPixelMeans': {min: 0, max: 1, palette: blueToRed},
  'edges': {min: 0, max: 1, palette: blueToRed},
  'smooth': {min: 0, max: 1, palette: blueToRed},
  'ndwi': {min: 0, max: 1, palette: ['blue', 'white', 'green']},
  'ndsi': {min: 0, max: 1, palette: ['darkblue','lightblue', 'white']},
  'ndvi': {min: 0, max: 1, palette: ['red','orange', 'yellow', 'green']},
  'slope': {min: 0, max: 1, palette: jet},
  'aspect': {min: 0, max: 1, palette: jet},
  'elevation': {min: 0, max: 1, palette: jet},
  'gradient': {min: 0, max: 1, palette: jet},
  'TPI': {min: 0, max: 1, palette: jet},
  'glacierInventory': {min: 0, max: 1, palette: ['white', 'blue']}
};
print('combinedImage', image);

//Map.addLayer(lstNir,  {min: 0, max: 1, palette: blueToRed},   'lstNir '+glacier+year , false);
Map.addLayer(ndri,    {min: 0, max: 1, palette: ['green', 'white', 'brown']}, 'ndri '+glacier+year, false);
Map.addLayer(superpixelMeans,{min: 0, max: 1, palette: blueToRed},  'super pixel means '+glacier+year , false);
Map.addLayer(edges,   {min: 0, max: 1, palette: blueToRed},         'edges '+glacier+year , false);
Map.addLayer(smoothLstNir,  {min: 0, max: 1, palette: blueToRed} ,  'smooth '+glacier+year, false);
Map.addLayer(ndwi,    {min: 0, max: 1, palette: ['blue', 'white', 'green']}, 'ndwi '+glacier+year , false);
Map.addLayer(ndsi,    {min: 0, max: 1, palette: ['darkblue','lightblue', 'white']}, 'ndsi '+glacier+year, false);
Map.addLayer(ndvi,    {min: 0, max: 1, palette: ['red','orange', 'yellow', 'green']}, 'ndvi '+glacier+year, false);
Map.addLayer(slope,   {min: 0, max: 1, palette: jet},   'slope '+glacier+year , false);
Map.addLayer(aspect,  {min: 0, max: 1, palette: jet},   'aspect '+glacier+year, false);
Map.addLayer(elevation,{min: 0, max: 1, palette: jet},  'elevation '+glacier+year, false);
Map.addLayer(gradient,{min: 0, max: 1, palette: jet},   'gradient_'+glacier+year, false);
Map.addLayer(TPI,     {min: 0, max: 1, palette: jet},   'TPI '+glacier+year, false);
Map.addLayer(glacierInventory, {min: 0, max: 1, palette: ['white', 'blue']}, 'glacier inventory '+glacier+year, false);
Map.addLayer(inSAR, {}, 'inSAR '+glacier+year, false);
Map.addLayer(coherence, {}, 'coherence'+glacier+year, false);
Map.addLayer(normalizedLst, {palette: jet}, 'lst'+glacier+year, false);
Map.addLayer(sentinel1, {bands: 'VH', min: 0, max: 1}, 'sentinel 1 GRD'+glacier+year, false);
Map.addLayer(combinedImage, trueColour, 'true colour'+glacier+year, false);
  }
}

var bands = ['lstNir', 'ndri', 'lstNir_superPixelMeans', 'edges', 'smooth', 'ndwi', 'ndsi', 'ndvi', 'slope', 'aspect', 'elevation', 'gradient', 'TPI', 'glacierInventory', 'inSAR', 'normalizedLst', 'coherence', 'VH', 'nd_swirNir'];

// Define glaciers and years
var glacierYearCombinations = [
/*
  {glacier: 'zmutt', year: 2016},
  {glacier: 'zmutt', year: 2018},
  {glacier: 'zmutt', year: 2020},
  {glacier: 'zmutt', year: 2022},
  {glacier: 'zmutt', year: 2024},

  { glacier: 'mauvoisin', year: 2016 },
  { glacier: 'mauvoisin', year: 2018 },
  { glacier: 'mauvoisin', year: 2020 },
  { glacier: 'mauvoisin', year: 2022 },
  { glacier: 'mauvoisin', year: 2024 },
 */
 // { glacier: 'unteraar', year: 2003 },
  { glacier: 'unteraar', year: 2016 },
  { glacier: 'unteraar', year: 2018 },
  { glacier: 'unteraar', year: 2020 },
  { glacier: 'unteraar', year: 2022 },
  { glacier: 'unteraar', year: 2024 },
  
 // { glacier: 'oberaletsch', year: 2003 },
  { glacier: 'oberaletsch', year: 2016 },
  { glacier: 'oberaletsch', year: 2018 },
  { glacier: 'oberaletsch', year: 2020 },
  { glacier: 'oberaletsch', year: 2022 },
  { glacier: 'oberaletsch', year: 2024 },
  
 // { glacier: 'belvedere', year: 2003 },
  { glacier: 'belvedere', year: 2016 },
  { glacier: 'belvedere', year: 2018 },
  { glacier: 'belvedere', year: 2020 },
  { glacier: 'belvedere', year: 2022 },
  { glacier: 'belvedere', year: 2024 },
  
  { glacier: 'zinal', year: 2016 },
  { glacier: 'zinal', year: 2018 },
  { glacier: 'zinal', year: 2020 },
  { glacier: 'zinal', year: 2022 },
  { glacier: 'zinal', year: 2024 },
/*  
  { glacier: 'satopanth', year: 2016 },
  { glacier: 'satopanth', year: 2018 },
  { glacier: 'satopanth', year: 2020 },
  { glacier: 'satopanth', year: 2022 },
  { glacier: 'satopanth', year: 2024 }
 */
];

// Loop over glacier-year combinations
glacierYearCombinations.forEach(function(combo) {
  generateLayersForGlacierYear(combo.glacier, combo.year);
});

Map.addLayer(debriscover, {color: 'blue'}, 'SGI 2016 debriscover', false);
